{"version":3,"sources":["Microcosm.js","webpack/bootstrap 11ee03ba66b7ec2af3ae","./src/index.js","./src/Heartbeat.js","./src/Microcosm.js","./src/promiseWrap.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Heartbeat","this","_callbacks","prototype","_pump","i","length","ignore","callback","filter","listen","concat","pump","_interopRequire","obj","__esModule","_extends","Object","assign","target","arguments","source","key","hasOwnProperty","_inherits","subClass","superClass","create","constructor","value","enumerable","writable","configurable","__proto__","promiseWrap","Microcosm","_Heartbeat","seed","stores","_state","getInitialState","undefined","set","_extends2","get","store","onError","error","send","fn","params","_this","request","then","body","dispatch","type","reduce","state","addStore","_len","Array","_key","serialize","memo","Promise","resolve"],"mappings":"AAAAA,OAAOC,QACE,SAAUC,GCGnB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAH,OAGA,IAAAD,GAAAK,EAAAD,IACAH,WACAK,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAR,EAAAC,QAAAD,IAAAC,QAAAE,GAGAH,EAAAO,QAAA,EAGAP,EAAAC,QAvBA,GAAAI,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDOM,SAASH,EAAQC,EAASE,GAE/B,YAQAH,GAAOC,QEjDOE,EAAQ,IFqDjB,SAASH,GAEd,YAEA,IAAIY,GAAkB,SAAUC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,sCGtDnGC,EAAS,WAEjB,QAFQA,KHmEhBJ,EAAgBK,KGnEAD,GAGjBC,KAAKC,cHkHN,MGrHkBF,GAASG,UAU5BC,MAAK,WAMH,IAAK,GAAIC,GAAI,EAAGA,EAAIJ,KAAKC,WAAWI,OAAQD,IAC1CJ,KAAKC,WAAWG,MAjBDL,EAASG,UAyB5BI,OAAM,SAACC,GACLP,KAAKC,WAAaD,KAAKC,WAAWO,OAAO,SAAAJ,GHqEtC,MGrE2CA,KAAMG,KA1BnCR,EAASG,UAgC5BO,OAAM,SAACF,GACLP,KAAKC,WAAaD,KAAKC,WAAWS,OAAOH,IAjCxBR,EAASG,UAuC5BS,KAAI,WACEX,KAAKC,WAAWI,OAAS,GAC3BL,KAAKG,SAzCUJ,IHwHpBhB,GAAOC,QGxHae,GH4Hf,SAAShB,EAAQC,EAASE,GAE/B,YAEA,IAAI0B,GAAkB,SAAUC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,EAAI,WAAaA,GAEnFE,EAAWC,OAAOC,QAAU,SAAUC,GAAU,IAAK,GAAId,GAAI,EAAGA,EAAIe,UAAUd,OAAQD,IAAK,CAAE,GAAIgB,GAASD,UAAUf,EAAI,KAAK,GAAIiB,KAAOD,GAAcJ,OAAOd,UAAUoB,eAAe/B,KAAK6B,EAAQC,KAAQH,EAAOG,GAAOD,EAAOC,IAAY,MAAOH,IAEnPK,EAAY,SAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAI3B,WAAU,iEAAoE2B,GAAeD,GAAStB,UAAYc,OAAOU,OAAOD,GAAcA,EAAWvB,WAAayB,aAAeC,MAAOJ,EAAUK,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeN,IAAYD,EAASQ,UAAYP,IAE9Z9B,EAAkB,SAAUC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,sCIzIjHC,EAASa,EAAA1B,EAAQ,IACjB+C,EAAWrB,EAAA1B,EAAM,IAEHgD,EAAS,SAAAC,GAEjB,QAFQD,GAEPE,GJkJTzC,EAAgBK,KIpJAkC,GAGjBC,EAAA5C,KAAAS,MAEAA,KAAKqC,UACLrC,KAAKsC,OAAStC,KAAKuC,gBAAgBH,GJwNpC,MAlEAb,GI5JkBW,EAASC,GAATD,EAAShC,UAS5BqC,gBAAe,WJsJZ,GItJaH,GAAII,SAAArB,UAAA,MAAGA,UAAA,EACrB,OAAAJ,MAAYqB,IAVKF,EAAShC,UAa5BuC,IAAG,SAACpB,EAAKO,GACP5B,KAAKsC,OAAMvB,KAAQf,KAAKsC,OAAM,WJwJ3B,GAAII,KAEJ,OADAA,GIzJ8BrB,GAAMO,EJ0J7Bc,OIxKOR,EAAShC,UAiB5ByC,IAAG,SAACC,GACF,MAAO5C,MAAKsC,OAAOM,IAAUA,EAAML,mBAlBlBL,EAAShC,UAqB5B2C,QAAO,SAACC,GACN,KAAMA,IAtBWZ,EAAShC,UAyB5B6C,KAAI,SAACC,EAAIC,GJ4JN,GAAIC,GAAQlD,KI3JTmD,EAAUlB,EAAYe,EAAGC,GAK7B,OAHAE,GAAQC,KAAK,SAAAC,GJ8JV,MI9JkBH,GAAKI,SAASN,EAAIK,KAAM,SAC/BrD,KAAK6C,SAEZM,GA/BUjB,EAAShC,UAkC5BoD,SAAQ,SAACC,EAAMF,GJ+JZ,GAAIH,GAAQlD,II9JbA,MAAKsC,OAAStC,KAAKqC,OAAOmB,OAAO,SAACC,EAAOb,GAIvC,MAHIW,KAAQX,KACVa,EAAMb,GAASA,EAAMW,GAAML,EAAKP,IAAIC,GAAQS,IAEvCI,GACR1C,KAAOf,KAAKsC,SAEbtC,KAAKW,QA1CYuB,EAAShC,UA6C5BwD,SAAQ,WJiKL,IAAK,GAAIC,GAAOxC,UAAUd,OIjKjBuC,EAAKgB,MAAAD,GAAAE,EAAA,EAAAF,EAAAE,MAALjB,EAAKiB,GAAA1C,UAAA0C,EACf7D,MAAKqC,OAASrC,KAAKqC,OAAO3B,OAAOkC,IA9ChBV,EAAShC,UAiD5B4D,UAAS,WJqKN,GAAIZ,GAAQlD,IIpKb,OAAOA,MAAKqC,OAAOmB,OAAO,SAACO,EAAMnB,GAE/B,MADAmB,GAAKnB,GAASM,EAAKP,IAAIC,GAChBmB,QApDQ7B,GAAkBnC,EJiOtChB,GAAOC,QIjOakD,GJqOf,SAASnD,GAEd,YAOAA,GAAOC,QKlPO,SAAA4C,GACb,MAAIA,aAAiBoC,SACZpC,EAEAoC,QAAQC,QAAQrC","file":"Microcosm.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\t/**\n\t * Microcosm\n\t * An isomorphic flux implimentation. The strength of Microcosm\n\t * is that each application is its own fully encapsulated world\n\t */\n\n\tmodule.exports = __webpack_require__(2);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n\t/**\n\t * Heartbeat\n\t * Based on Diode, emits a heartbeat whenever any store state has changed.\n\t * When Stores change, they can use this entity to broadcast\n\t * that state has changed.\n\t *\n\t * See https://github.com/vigetlabs/diode\n\t */\n\n\tvar Heartbeat = (function () {\n\t  function Heartbeat() {\n\t    _classCallCheck(this, Heartbeat);\n\n\t    this._callbacks = [];\n\t  }\n\n\t  /**\n\t   * Callbacks are eventually executed, Heartbeat does not promise\n\t   * immediate consistency so that state propagation can be batched\n\t   */\n\n\t  Heartbeat.prototype._pump = function _pump() {\n\t    /**\n\t     * Important: do not cache the length of _callbacks\n\t     * in the event a callback causes later subscriptions\n\t     * to disappear\n\t     */\n\t    for (var i = 0; i < this._callbacks.length; i++) {\n\t      this._callbacks[i]();\n\t    }\n\t  };\n\n\t  /**\n\t   * Given a CALLBACK function, remove it from the Set of callbacks.\n\t   * Throws an error if the callback is not included in the Set.\n\t   */\n\n\t  Heartbeat.prototype.ignore = function ignore(callback) {\n\t    this._callbacks = this._callbacks.filter(function (i) {\n\t      return i !== callback;\n\t    });\n\t  };\n\n\t  /**\n\t   * Given a CALLBACK function, add it to the Set of all callbacks.\n\t   */\n\n\t  Heartbeat.prototype.listen = function listen(callback) {\n\t    this._callbacks = this._callbacks.concat(callback);\n\t  };\n\n\t  /**\n\t   * Trigger every callback in the Set\n\t   */\n\n\t  Heartbeat.prototype.pump = function pump() {\n\t    if (this._callbacks.length > 0) {\n\t      this._pump();\n\t    }\n\t  };\n\n\t  return Heartbeat;\n\t})();\n\n\tmodule.exports = Heartbeat;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\tvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n\t/**\n\t * Microcosm\n\t * An isomorphic flux implimentation. The strength of Microcosm\n\t * is that each application is its own fully encapsulated world\n\t */\n\n\tvar Heartbeat = _interopRequire(__webpack_require__(1));\n\n\tvar promiseWrap = _interopRequire(__webpack_require__(3));\n\n\tvar Microcosm = (function (_Heartbeat) {\n\t  function Microcosm(seed) {\n\t    _classCallCheck(this, Microcosm);\n\n\t    _Heartbeat.call(this);\n\n\t    this.stores = [];\n\t    this._state = this.getInitialState(seed);\n\t  }\n\n\t  _inherits(Microcosm, _Heartbeat);\n\n\t  Microcosm.prototype.getInitialState = function getInitialState() {\n\t    var seed = arguments[0] === undefined ? {} : arguments[0];\n\n\t    return _extends({}, seed);\n\t  };\n\n\t  Microcosm.prototype.set = function set(key, value) {\n\t    this._state = _extends({}, this._state, (function () {\n\t      var _extends2 = {};\n\t      _extends2[key] = value;\n\t      return _extends2;\n\t    })());\n\t  };\n\n\t  Microcosm.prototype.get = function get(store) {\n\t    return this._state[store] || store.getInitialState();\n\t  };\n\n\t  Microcosm.prototype.onError = function onError(error) {\n\t    throw error;\n\t  };\n\n\t  Microcosm.prototype.send = function send(fn, params) {\n\t    var _this = this;\n\n\t    var request = promiseWrap(fn(params));\n\n\t    request.then(function (body) {\n\t      return _this.dispatch(fn, body);\n\t    })[\"catch\"](this.onError);\n\n\t    return request;\n\t  };\n\n\t  Microcosm.prototype.dispatch = function dispatch(type, body) {\n\t    var _this = this;\n\n\t    this._state = this.stores.reduce(function (state, store) {\n\t      if (type in store) {\n\t        state[store] = store[type](_this.get(store), body);\n\t      }\n\t      return state;\n\t    }, _extends({}, this._state));\n\n\t    this.pump();\n\t  };\n\n\t  Microcosm.prototype.addStore = function addStore() {\n\t    for (var _len = arguments.length, store = Array(_len), _key = 0; _key < _len; _key++) {\n\t      store[_key] = arguments[_key];\n\t    }\n\n\t    this.stores = this.stores.concat(store);\n\t  };\n\n\t  Microcosm.prototype.serialize = function serialize() {\n\t    var _this = this;\n\n\t    return this.stores.reduce(function (memo, store) {\n\t      memo[store] = _this.get(store);\n\t      return memo;\n\t    }, {});\n\t  };\n\n\t  return Microcosm;\n\t})(Heartbeat);\n\n\tmodule.exports = Microcosm;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\t/**\n\t * PromiseWrap\n\t * Makes sure a given value is always a promise\n\t */\n\n\tmodule.exports = function (value) {\n\t  if (value instanceof Promise) {\n\t    return value;\n\t  } else {\n\t    return Promise.resolve(value);\n\t  }\n\t};\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** Microcosm.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 11ee03ba66b7ec2af3ae\n **/","/**\n * Microcosm\n * An isomorphic flux implimentation. The strength of Microcosm\n * is that each application is its own fully encapsulated world\n */\n\nexport default require('./Microcosm')\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/**\n * Heartbeat\n * Based on Diode, emits a heartbeat whenever any store state has changed.\n * When Stores change, they can use this entity to broadcast\n * that state has changed.\n *\n * See https://github.com/vigetlabs/diode\n */\n\nexport default class Heartbeat {\n\n  constructor() {\n    this._callbacks = []\n  }\n\n  /**\n   * Callbacks are eventually executed, Heartbeat does not promise\n   * immediate consistency so that state propagation can be batched\n   */\n  _pump() {\n    /**\n     * Important: do not cache the length of _callbacks\n     * in the event a callback causes later subscriptions\n     * to disappear\n     */\n    for (var i = 0; i < this._callbacks.length; i++) {\n      this._callbacks[i]()\n    }\n  }\n\n  /**\n   * Given a CALLBACK function, remove it from the Set of callbacks.\n   * Throws an error if the callback is not included in the Set.\n   */\n  ignore(callback) {\n    this._callbacks = this._callbacks.filter(i => i !== callback)\n  }\n\n  /**\n   * Given a CALLBACK function, add it to the Set of all callbacks.\n   */\n  listen(callback) {\n    this._callbacks = this._callbacks.concat(callback)\n  }\n\n  /**\n   * Trigger every callback in the Set\n   */\n  pump() {\n    if (this._callbacks.length > 0) {\n      this._pump()\n    }\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Heartbeat.js\n **/","/**\n * Microcosm\n * An isomorphic flux implimentation. The strength of Microcosm\n * is that each application is its own fully encapsulated world\n */\n\nimport Heartbeat   from 'Heartbeat'\nimport promiseWrap from 'promiseWrap'\n\nexport default class Microcosm extends Heartbeat {\n\n  constructor(seed) {\n    super()\n\n    this.stores = []\n    this._state = this.getInitialState(seed)\n  }\n\n  getInitialState(seed={}) {\n    return { ...seed }\n  }\n\n  set(key, value) {\n    this._state = { ...this._state, [key]: value }\n  }\n\n  get(store) {\n    return this._state[store] || store.getInitialState()\n  }\n\n  onError(error) {\n    throw error\n  }\n\n  send(fn, params) {\n    let request = promiseWrap(fn(params))\n\n    request.then(body => this.dispatch(fn, body))\n           .catch(this.onError)\n\n    return request\n  }\n\n  dispatch(type, body) {\n    this._state = this.stores.reduce((state, store) => {\n      if (type in store) {\n        state[store] = store[type](this.get(store), body)\n      }\n      return state\n    }, { ...this._state })\n\n    this.pump()\n  }\n\n  addStore(...store) {\n    this.stores = this.stores.concat(store)\n  }\n\n  serialize() {\n    return this.stores.reduce((memo, store) => {\n      memo[store] = this.get(store)\n      return memo\n    }, {})\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Microcosm.js\n **/","/**\n * PromiseWrap\n * Makes sure a given value is always a promise\n */\n\nexport default value => {\n  if (value instanceof Promise) {\n    return value\n  } else {\n    return Promise.resolve(value)\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/promiseWrap.js\n **/"],"sourceRoot":""}