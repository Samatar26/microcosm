{"version":3,"sources":["Microcosm.js","webpack/bootstrap 3f9466918f76249f286c","./src/index.js","./src/Microcosm.js","./src/isMicrocosm.js","./src/remap.js","./src/Downstream.js","./src/Store.js","./src/Upstream.js","./src/assert.js","./src/copyIf.js","./src/install.js","./src/pulse.js","./src/tag.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__esModule","tag","Upstream","Downstream","_interopRequire","obj","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","_classCallCheck","instance","Constructor","TypeError","Store","assert","copyIf","install","pulse","remap","Microcosm","this","_state","_stores","_plugins","push","data","commit","deserialize","pull","clone","create","next","emit","prepare","fn","_send","_len","buffer","Array","_key","send","bind","apply","concat","_this","params","request","Promise","then","body","dispatch","action","changes","store","keys","staged","addPlugin","plugin","options","addStore","safe","serialize","undefined","toJSON","toObject","start","getInitialState","forEach","callback","props","propName","componentName","Error","transform","initial","reduce","memo","isMicrocosm","contextTypes","app","_context$app","context","state","toString","childContextTypes","getChildContext","_props$app","bool","message","error","framesToPop","object","predicate","copy","_ref","_ref2","_toArray","tail","slice","_plugin","_slicedToArray","driver","register","err","arr","isArray","Symbol","iterator","_step","_arr","_iterator","done","value","from","infuse","callbacks","ignore","filter","listen","isFunction","decorate","uid","actions"],"mappings":"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","file":"Microcosm.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports.__esModule = true;\n\t/**\n\t * Microcosm\n\t * An isomorphic flux implimentation. The strength of Microcosm\n\t * is that each application is its own fully encapsulated world\n\t */\n\n\tvar tag = __webpack_require__(11);\n\texports.tag = tag;\n\tvar Upstream = __webpack_require__(6);\n\texports.Upstream = Upstream;\n\tvar Downstream = __webpack_require__(4);\n\n\texports.Downstream = Downstream;\n\texports[\"default\"] = __webpack_require__(1);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n\t/**\n\t * Microcosm\n\t * An isomorphic flux implementation. The strength of Microcosm\n\t * is that each application is its own fully encapsulated world.\n\t */\n\n\tvar Store = _interopRequire(__webpack_require__(5));\n\n\tvar assert = _interopRequire(__webpack_require__(7));\n\n\tvar copyIf = _interopRequire(__webpack_require__(8));\n\n\tvar install = _interopRequire(__webpack_require__(9));\n\n\tvar pulse = _interopRequire(__webpack_require__(10));\n\n\tvar remap = _interopRequire(__webpack_require__(3));\n\n\tvar Microcosm = (function () {\n\t  function Microcosm() {\n\t    _classCallCheck(this, Microcosm);\n\n\t    pulse(this);\n\n\t    this._state = {};\n\t    this._stores = {};\n\t    this._plugins = [];\n\t  }\n\n\t  Microcosm.prototype.push = function push(data) {\n\t    this.commit(this.deserialize(data));\n\t  };\n\n\t  Microcosm.prototype.pull = function pull(key) {\n\t    return this._state[key];\n\t  };\n\n\t  Microcosm.prototype.clone = function clone() {\n\t    return Object.create(this._state);\n\t  };\n\n\t  Microcosm.prototype.commit = function commit(next) {\n\t    this._state = next;\n\t    this.emit();\n\t  };\n\n\t  Microcosm.prototype.prepare = function prepare(fn) {\n\t    var _send;\n\n\t    for (var _len = arguments.length, buffer = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      buffer[_key - 1] = arguments[_key];\n\t    }\n\n\t    assert(typeof fn === \"function\", \"prepare was called with no callable action.\");\n\t    return (_send = this.send).bind.apply(_send, [this, fn].concat(buffer));\n\t  };\n\n\t  Microcosm.prototype.send = function send(fn) {\n\t    var _this = this;\n\n\t    for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      params[_key - 1] = arguments[_key];\n\t    }\n\n\t    assert(fn, \"send method expected an action, instead got \" + fn);\n\n\t    var request = fn.apply(this, params);\n\n\t    // Actions some times return promises. When this happens, wait for\n\t    // them to resolve before moving on\n\t    if (request instanceof Promise) {\n\t      return request.then(function (body) {\n\t        return _this.dispatch(fn, body);\n\t      });\n\t    }\n\n\t    return this.dispatch(fn, request);\n\t  };\n\n\t  Microcosm.prototype.dispatch = function dispatch(action, body) {\n\t    var _this = this;\n\n\t    var changes = copyIf(this._stores, function (store) {\n\t      return action in store;\n\t    });\n\n\t    if (Object.keys(changes).length > 0) {\n\t      (function () {\n\t        var clone = _this.clone();\n\n\t        var staged = remap(changes, function (store) {\n\t          return store[action](clone[store], body);\n\t        }, clone);\n\n\t        _this.commit(staged);\n\t      })();\n\t    }\n\n\t    return body;\n\t  };\n\n\t  Microcosm.prototype.addPlugin = function addPlugin(plugin, options) {\n\t    assert(\"register\" in plugin, \"Plugins must have a register method.\");\n\t    this._plugins.push([plugin, options]);\n\t  };\n\n\t  Microcosm.prototype.addStore = function addStore(store) {\n\t    // Make sure life cycle methods are included\n\t    var safe = _extends({}, Store, store);\n\n\t    // Don't reassign stores that are already included. Fail hard.\n\t    assert(!this._stores[store], \"Tried to add \\\"\" + store + \"\\\" but it is not unique\");\n\n\t    // Add the validated stores to the list of known entities\n\t    this._stores[safe] = safe;\n\t  };\n\n\t  Microcosm.prototype.serialize = function serialize() {\n\t    var _this = this;\n\n\t    return remap(this._stores, function (store) {\n\t      return store.serialize(_this.pull(store));\n\t    });\n\t  };\n\n\t  Microcosm.prototype.deserialize = function deserialize() {\n\t    var data = arguments[0] === undefined ? {} : arguments[0];\n\n\t    return remap(this._stores, function (store) {\n\t      return store.deserialize(data[store]);\n\t    });\n\t  };\n\n\t  Microcosm.prototype.toJSON = function toJSON() {\n\t    return this.serialize();\n\t  };\n\n\t  Microcosm.prototype.toObject = function toObject() {\n\t    return copyIf(this._state, function () {\n\t      return true;\n\t    });\n\t  };\n\n\t  Microcosm.prototype.start = function start() {\n\t    for (var _len = arguments.length, next = Array(_len), _key = 0; _key < _len; _key++) {\n\t      next[_key] = arguments[_key];\n\t    }\n\n\t    // Start by producing the initial state\n\t    this._state = remap(this._stores, function (store) {\n\t      return store.getInitialState();\n\t    });\n\n\t    // Queue plugins and then notify that installation has finished\n\t    install(this._plugins, this, function () {\n\t      next.forEach(function (callback) {\n\t        return callback();\n\t      });\n\t    });\n\t  };\n\n\t  return Microcosm;\n\t})();\n\n\tmodule.exports = Microcosm;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\n\tvar Microcosm = _interopRequire(__webpack_require__(1));\n\n\tmodule.exports = function (props, propName, componentName) {\n\t  if (props[propName] instanceof Microcosm === false) {\n\t    throw new Error(\"Context type \" + propName + \" of <\" + componentName + \"> should be an instance of Microcosm\");\n\t  }\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * remap\n\t * Take an object and assign new values onto another object\n\t * given a transformation function\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = remap;\n\n\tfunction remap(obj, transform) {\n\t  var initial = arguments[2] === undefined ? {} : arguments[2];\n\n\t  var keys = Object.keys(obj);\n\n\t  return keys.reduce(function (memo, key) {\n\t    memo[key] = transform(obj[key], key);\n\t    return memo;\n\t  }, initial);\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\n\tvar isMicrocosm = _interopRequire(__webpack_require__(2));\n\n\tmodule.exports = {\n\t  contextTypes: {\n\t    app: isMicrocosm\n\t  },\n\n\t  send: function send(action) {\n\t    var _context$app;\n\n\t    for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      params[_key - 1] = arguments[_key];\n\t    }\n\n\t    (_context$app = this.context.app).send.apply(_context$app, [action].concat(params));\n\t  }\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tmodule.exports = {\n\n\t  getInitialState: function getInitialState() {\n\t    return undefined;\n\t  },\n\n\t  serialize: function serialize(state) {\n\t    return state;\n\t  },\n\n\t  deserialize: function deserialize() {\n\t    var state = arguments[0] === undefined ? this.getInitialState() : arguments[0];\n\n\t    return state;\n\t  },\n\n\t  toString: function toString() {\n\t    throw new Error(\"Stores must implement a toString() method\");\n\t  }\n\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\n\tvar isMicrocosm = _interopRequire(__webpack_require__(2));\n\n\tmodule.exports = {\n\t  childContextTypes: {\n\t    app: isMicrocosm\n\t  },\n\n\t  getChildContext: function getChildContext() {\n\t    return {\n\t      app: this.props.app || this.context.app\n\t    };\n\t  },\n\n\t  send: function send(action) {\n\t    var _props$app;\n\n\t    for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      params[_key - 1] = arguments[_key];\n\t    }\n\n\t    (_props$app = this.props.app).send.apply(_props$app, [action].concat(params));\n\t  }\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * assert\n\t * If not true, throw an error\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = assert;\n\n\tfunction assert(bool, message) {\n\t  if (!bool) {\n\t    var error = new Error(message);\n\n\t    // Remove `assert` from the stack\n\t    error.framesToPop = 1;\n\n\t    throw error;\n\t  }\n\t}\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * CopyIf\n\t * Copy wanted keys from an object\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = function (object, predicate) {\n\t  var copy = {};\n\n\t  for (var i in object) {\n\t    if (predicate(object[i])) {\n\t      copy[i] = object[i];\n\t    }\n\t  }\n\n\t  return copy;\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } };\n\n\tvar _toArray = function (arr) { return Array.isArray(arr) ? arr : Array.from(arr); };\n\n\t/**\n\t * Install\n\t * A simple FIFO queue for installing plugins\n\t */\n\n\tmodule.exports = install;\n\n\tfunction install(_ref, app, callback) {\n\t  var _ref2 = _toArray(_ref);\n\n\t  var plugin = _ref2[0];\n\n\t  var tail = _ref2.slice(1);\n\n\t  if (!plugin) {\n\t    return callback();\n\t  }\n\t  var _plugin = _slicedToArray(plugin, 2);\n\n\t  var driver = _plugin[0];\n\t  var options = _plugin[1];\n\n\t  driver.register(app, options, function (err) {\n\t    if (err) throw err;\n\t    install(tail, app, callback);\n\t  });\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Pulse\n\t * A singular event emitter. Pulse is simply the result of pulseing\n\t * blood.\n\t *\n\t * This is a factory/decorator depending on usage. There are some\n\t * compression benefits to this, prevents the need to use super.\n\t */\n\n\t\"use strict\";\n\n\tfunction pulse() {\n\t  var infuse = arguments[0] === undefined ? {} : arguments[0];\n\n\t  var callbacks = [];\n\n\t  /**\n\t   * Given a CALLBACK function, remove it from the Set of callbacks.\n\t   * Throws an error if the callback is not included in the Set.\n\t   */\n\t  infuse.ignore = function (callback) {\n\t    callbacks = callbacks.filter(function (i) {\n\t      return i !== callback;\n\t    });\n\t  };\n\n\t  /**\n\t   * Given a CALLBACK function, add it to the Set of all callbacks.\n\t   */\n\t  infuse.listen = function (callback) {\n\t    callbacks.push(callback);\n\t  };\n\n\t  /**\n\t   * Trigger every callback in the Set\n\t   */\n\t  infuse.emit = function () {\n\t    /**\n\t     * Important: do not cache the length of _callbacks\n\t     * in the event a callback causes later subscriptions\n\t     * to disappear\n\t     */\n\t    for (var i = 0; i < callbacks.length; i++) {\n\t      callbacks[i].call(this);\n\t    }\n\t  };\n\n\t  return infuse;\n\t}\n\n\tmodule.exports = pulse;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\n\t/**\n\t * Tag\n\t * Given an object of methods, modify each method to\n\t * return a unique id when stringifyed\n\t */\n\n\tvar remap = _interopRequire(__webpack_require__(3));\n\n\tvar uid = 0;\n\n\tfunction isFunction(value) {\n\t  return typeof value === \"function\";\n\t}\n\n\tfunction decorate(fn, key) {\n\t  var copy = fn.bind(null);\n\t  var id = \"_\" + key + \"_\" + uid++;\n\n\t  copy.toString = function () {\n\t    return id;\n\t  };\n\n\t  return copy;\n\t}\n\n\tmodule.exports = function (actions) {\n\t  return remap(actions, function (value, key) {\n\t    return isFunction(value) ? decorate(value, key) : value;\n\t  });\n\t};\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** Microcosm.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 3f9466918f76249f286c\n **/","/**\n * Microcosm\n * An isomorphic flux implimentation. The strength of Microcosm\n * is that each application is its own fully encapsulated world\n */\n\nexport let tag = require('./tag')\nexport let Upstream = require('./Upstream')\nexport let Downstream = require('./Downstream')\n\nexport default require('./Microcosm')\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/**\n * Microcosm\n * An isomorphic flux implementation. The strength of Microcosm\n * is that each application is its own fully encapsulated world.\n */\n\nimport Store   from './Store'\nimport assert  from './assert'\nimport copyIf  from './copyIf'\nimport install from './install'\nimport pulse   from './pulse'\nimport remap   from './remap'\n\nexport default class Microcosm {\n\n  constructor() {\n    pulse(this)\n\n    this._state   = {}\n    this._stores  = {}\n    this._plugins = []\n  }\n\n  push(data) {\n    this.commit(this.deserialize(data))\n  }\n\n  pull(key) {\n    return this._state[key]\n  }\n\n  clone() {\n    return Object.create(this._state)\n  }\n\n  commit(next) {\n    this._state = next\n    this.emit()\n  }\n\n  prepare(fn, ...buffer) {\n    assert(typeof fn === 'function', 'prepare was called with no callable action.')\n    return this.send.bind(this, fn, ...buffer)\n  }\n\n  send(fn, ...params) {\n    assert(fn, `send method expected an action, instead got ${ fn }`)\n\n    const request = fn.apply(this, params)\n\n    // Actions some times return promises. When this happens, wait for\n    // them to resolve before moving on\n    if (request instanceof Promise) {\n      return request.then(body => this.dispatch(fn, body))\n    }\n\n    return this.dispatch(fn, request)\n  }\n\n  dispatch(action, body) {\n    let changes = copyIf(this._stores, store => action in store)\n\n    if (Object.keys(changes).length > 0) {\n      let clone  = this.clone()\n\n      let staged = remap(changes,\n                         store => store[action](clone[store], body),\n                         clone)\n\n      this.commit(staged)\n    }\n\n    return body\n  }\n\n  addPlugin(plugin, options) {\n    assert('register' in plugin, 'Plugins must have a register method.')\n    this._plugins.push([ plugin, options ])\n  }\n\n  addStore(store) {\n    // Make sure life cycle methods are included\n    const safe = { ...Store, ...store }\n\n    // Don't reassign stores that are already included. Fail hard.\n    assert(!this._stores[store], `Tried to add \"${store}\" but it is not unique`)\n\n    // Add the validated stores to the list of known entities\n    this._stores[safe] = safe\n  }\n\n  serialize() {\n    return remap(this._stores, store => store.serialize(this.pull(store)))\n  }\n\n  deserialize(data={}) {\n    return remap(this._stores, store => store.deserialize(data[store]))\n  }\n\n  toJSON() {\n    return this.serialize()\n  }\n\n  toObject() {\n    return copyIf(this._state, () => true)\n  }\n\n  start(...next) {\n    // Start by producing the initial state\n    this._state = remap(this._stores, store => store.getInitialState())\n\n    // Queue plugins and then notify that installation has finished\n    install(this._plugins, this, function() {\n      next.forEach(callback => callback())\n    })\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Microcosm.js\n **/","import Microcosm from 'Microcosm'\n\nexport default function(props, propName, componentName) {\n  if (props[propName] instanceof Microcosm === false) {\n    throw new Error(`Context type ${ propName } of <${componentName}> should be an instance of Microcosm`)\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/isMicrocosm.js\n **/","/*\n * remap\n * Take an object and assign new values onto another object\n * given a transformation function\n */\n\nexport default function remap (obj, transform, initial={}) {\n  let keys = Object.keys(obj)\n\n  return keys.reduce(function(memo, key) {\n    memo[key] = transform(obj[key], key)\n    return memo\n  }, initial)\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/remap.js\n **/","import isMicrocosm from 'isMicrocosm'\n\nexport default {\n  contextTypes: {\n    app: isMicrocosm\n  },\n\n  send(action, ...params) {\n    this.context.app.send(action, ...params)\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Downstream.js\n **/","export default {\n\n  getInitialState() {\n    return undefined\n  },\n\n  serialize(state) {\n    return state\n  },\n\n  deserialize(state = this.getInitialState()) {\n    return state\n  },\n\n  toString() {\n    throw new Error('Stores must implement a toString() method')\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Store.js\n **/","import isMicrocosm from 'isMicrocosm'\n\nexport default {\n  childContextTypes: {\n    app: isMicrocosm\n  },\n\n  getChildContext() {\n    return {\n      app: this.props.app || this.context.app\n    }\n  },\n\n  send(action, ...params) {\n    this.props.app.send(action, ...params)\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Upstream.js\n **/","/**\n * assert\n * If not true, throw an error\n */\n\nexport default function assert (bool, message) {\n  if (!bool) {\n    const error = new Error(message)\n\n    // Remove `assert` from the stack\n    error.framesToPop = 1;\n\n    throw error\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/assert.js\n **/","/**\n * CopyIf\n * Copy wanted keys from an object\n */\n\nexport default function (object, predicate) {\n  let copy = {}\n\n  for (var i in object) {\n    if (predicate(object[i])) {\n      copy[i] = object[i]\n    }\n  }\n\n  return copy\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/copyIf.js\n **/","/**\n * Install\n * A simple FIFO queue for installing plugins\n */\n\nexport default function install ([plugin, ...tail], app, callback) {\n  if (!plugin) return callback()\n\n  let [ driver, options ] = plugin\n\n  driver.register(app, options, function(err) {\n    if (err) throw err\n    install(tail, app, callback)\n  })\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/install.js\n **/","/**\n * Pulse\n * A singular event emitter. Pulse is simply the result of pulseing\n * blood.\n *\n * This is a factory/decorator depending on usage. There are some\n * compression benefits to this, prevents the need to use super.\n */\n\nfunction pulse (infuse={}) {\n  let callbacks = []\n\n  /**\n   * Given a CALLBACK function, remove it from the Set of callbacks.\n   * Throws an error if the callback is not included in the Set.\n   */\n  infuse.ignore = function (callback) {\n    callbacks = callbacks.filter(i => i !== callback)\n  }\n\n  /**\n   * Given a CALLBACK function, add it to the Set of all callbacks.\n   */\n  infuse.listen = function (callback) {\n    callbacks.push(callback)\n  }\n\n  /**\n   * Trigger every callback in the Set\n   */\n  infuse.emit = function () {\n    /**\n     * Important: do not cache the length of _callbacks\n     * in the event a callback causes later subscriptions\n     * to disappear\n     */\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i].call(this)\n    }\n  }\n\n  return infuse\n}\n\nexport default pulse\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/pulse.js\n **/","/**\n * Tag\n * Given an object of methods, modify each method to\n * return a unique id when stringifyed\n */\n\nimport remap from './remap'\n\nlet uid = 0\n\nfunction isFunction (value) {\n  return typeof value === 'function'\n}\n\nfunction decorate (fn, key) {\n  const copy = fn.bind(null)\n  const id   = `_${ key }_${ uid++ }`\n\n  copy.toString = () => id\n\n  return copy\n}\n\nexport default actions => {\n  return remap(actions, function(value, key) {\n    return isFunction(value) ? decorate(value, key) : value\n  })\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/tag.js\n **/"],"sourceRoot":""}