{"version":3,"sources":["Microcosm.js","webpack/bootstrap 80699a3847c97b7032ab","./src/index.js","./src/mapBy.js","./src/Microcosm.js","./src/Store.js","./src/assert.js","./src/assign.js","./src/install.js","./src/pulse.js","./src/shallowEquals.js","./src/tag.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__esModule","tag","mapBy","array","fn","initial","undefined","arguments","reduce","memo","next","_interopRequire","obj","_classCallCheck","instance","Constructor","TypeError","Store","assert","assign","install","isEqual","pulse","Microcosm","options","this","_options","_plugins","_state","getInitialState","_stores","prototype","shouldUpdate","prev","has","key","some","store","get","swap","reset","pump","prepare","_send","_len","length","buffer","Array","_key","send","bind","apply","concat","_this","params","request","Promise","then","body","dispatch","clone","Object","create","action","answerable","filter","addPlugin","plugin","push","addStore","safe","start","done","serialize","deserialize","data","seed","toJSON","state","toString","Error","bool","message","error","framesToPop","a","b","_extends","target","i","source","hasOwnProperty","_ref","app","callback","_ref2","_toArray","tail","slice","register","err","arr","isArray","from","infuse","callbacks","ignore","listen","isFunction","value","decorate","copy","uid","actions","keys"],"mappings":"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","file":"Microcosm.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports.__esModule = true;\n\t/**\n\t * Microcosm\n\t * An isomorphic flux implimentation. The strength of Microcosm\n\t * is that each application is its own fully encapsulated world\n\t */\n\n\tvar tag = __webpack_require__(9);\n\texports.tag = tag;\n\texports[\"default\"] = __webpack_require__(2);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * MapBy\n\t * Take a list and reduce it into an object\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = mapBy;\n\n\tfunction mapBy(array, fn) {\n\t  var initial = arguments[2] === undefined ? {} : arguments[2];\n\n\t  return array.reduce(function (memo, next) {\n\t    memo[next] = fn(next);\n\t    return memo;\n\t  }, initial);\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n\t/**\n\t * Microcosm\n\t * An isomorphic flux implementation. The strength of Microcosm\n\t * is that each application is its own fully encapsulated world\n\t */\n\n\tvar Store = _interopRequire(__webpack_require__(3));\n\n\tvar assert = _interopRequire(__webpack_require__(4));\n\n\tvar assign = _interopRequire(__webpack_require__(5));\n\n\tvar install = _interopRequire(__webpack_require__(6));\n\n\tvar isEqual = _interopRequire(__webpack_require__(8));\n\n\tvar mapBy = _interopRequire(__webpack_require__(1));\n\n\tvar pulse = _interopRequire(__webpack_require__(7));\n\n\tvar Microcosm = (function () {\n\t  function Microcosm() {\n\t    var options = arguments[0] === undefined ? {} : arguments[0];\n\n\t    _classCallCheck(this, Microcosm);\n\n\t    pulse(this);\n\n\t    this._options = options;\n\t    this._plugins = [];\n\t    this._state = this.getInitialState(options);\n\t    this._stores = [];\n\t  }\n\n\t  Microcosm.prototype.getInitialState = function getInitialState() {\n\t    // Assigns the default state. Most of the time this will not need\n\t    // to be overridden, however if using something like ImmutableJS,\n\t    // you could return a different data structure here.\n\t    return {};\n\t  };\n\n\t  Microcosm.prototype.shouldUpdate = function shouldUpdate(prev, next) {\n\t    // Whenever an action is dispatched, the resulting state\n\t    // modification will be diffed to identify if a change event\n\t    // should fire.\n\t    //\n\t    // The default strategy for determining that state has changed\n\t    // is a simple shallow equals check\n\t    return isEqual(prev, next) === false;\n\t  };\n\n\t  Microcosm.prototype.has = function has(key) {\n\t    // Does this instance of microcosm contain the given store?\n\t    // Important: Uses the unique identifier, not the object reference\n\t    return this._stores.some(function (store) {\n\t      return \"\" + key === \"\" + store;\n\t    });\n\t  };\n\n\t  Microcosm.prototype.get = function get(key) {\n\t    // How state should be retrieved. This function is useful to\n\t    // override with the particular method of retrieval for the data\n\t    // structure returned from `getInitialState`\n\t    return this._state[key];\n\t  };\n\n\t  Microcosm.prototype.swap = function swap(next) {\n\t    // Swap is basically a reset where the next state is the result of\n\t    // folding one object over the next\n\t    this.reset(assign(this._state, next));\n\t  };\n\n\t  Microcosm.prototype.reset = function reset(next) {\n\t    // Given a next state, only trigger an event if state actually changed\n\t    if (this.shouldUpdate(this._state, next)) {\n\t      this._state = next;\n\t      this.pump();\n\t    }\n\t  };\n\n\t  Microcosm.prototype.prepare = function prepare(fn) {\n\t    var _send;\n\n\t    for (var _len = arguments.length, buffer = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      buffer[_key - 1] = arguments[_key];\n\t    }\n\n\t    return (_send = this.send).bind.apply(_send, [this, fn].concat(buffer));\n\t  };\n\n\t  Microcosm.prototype.send = function send(fn) {\n\t    var _this = this;\n\n\t    for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      params[_key - 1] = arguments[_key];\n\t    }\n\n\t    var request = fn.apply(this, params);\n\n\t    // Actions some times return promises. When this happens, wait for\n\t    // them to resolve before moving on\n\t    if (request instanceof Promise) {\n\t      return request.then(function (body) {\n\t        return _this.dispatch(fn, body);\n\t      });\n\t    }\n\n\t    return this.dispatch(fn, request);\n\t  };\n\n\t  Microcosm.prototype.clone = function clone() {\n\t    return Object.create(this._state);\n\t  };\n\n\t  Microcosm.prototype.dispatch = function dispatch(action, body) {\n\t    var clone = this.clone();\n\n\t    // First get all stores that can repond to this action\n\t    var answerable = this._stores.filter(function (store) {\n\t      return action in store;\n\t    });\n\n\t    // Next build the change set\n\t    var next = mapBy(answerable, function (store) {\n\t      return store[action](clone[store], body);\n\t    }, clone);\n\n\t    // Produce the next state by merging changes into the current state\n\t    this.reset(next);\n\n\t    // Send back the body to the original signaler\n\t    return body;\n\t  };\n\n\t  Microcosm.prototype.addPlugin = function addPlugin(plugin) {\n\t    assert(\"register\" in plugin, \"Plugins must have a register method.\");\n\t    this._plugins.push(plugin);\n\t  };\n\n\t  Microcosm.prototype.addStore = function addStore(store) {\n\t    // Make sure life cycle methods are included\n\t    var safe = assign(Store, store);\n\n\t    // Don't reassign stores that are already included. Fail hard.\n\t    assert(!this.has(safe), \"Tried to add \\\"\" + store + \"\\\" but it is not unique\");\n\n\t    // Add the validated stores to the list of known entities\n\t    this._stores.push(safe);\n\t  };\n\n\t  Microcosm.prototype.start = function start(done) {\n\t    // Start by setting the initial state to the result of calling\n\t    // `getInitialState` on the microcosm and all of its stores\n\t    this._state = mapBy(this._stores, function (store) {\n\t      return store.getInitialState();\n\t    }, this.getInitialState());\n\n\t    // Finally, queue plugins and then notify that installation has\n\t    // finished\n\t    install(this._plugins, this, done);\n\t  };\n\n\t  Microcosm.prototype.serialize = function serialize() {\n\t    var _this = this;\n\n\t    return mapBy(this._stores, function (store) {\n\t      return store.serialize(_this.get(store));\n\t    });\n\t  };\n\n\t  Microcosm.prototype.deserialize = function deserialize() {\n\t    var data = arguments[0] === undefined ? {} : arguments[0];\n\n\t    return mapBy(this._stores, function (store) {\n\t      return store.deserialize(data[store]);\n\t    });\n\t  };\n\n\t  Microcosm.prototype.seed = function seed(data) {\n\t    // Tells the microcosm how it should handle data injected from\n\t    // sources.\n\t    //\n\t    // By default, it will clean the data with `deserialize` and\n\t    // then reset the existing data set with the new values\n\t    this.reset(this.deserialize(data));\n\t  };\n\n\t  Microcosm.prototype.toJSON = function toJSON() {\n\t    return this.serialize();\n\t  };\n\n\t  return Microcosm;\n\t})();\n\n\tmodule.exports = Microcosm;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tmodule.exports = {\n\n\t  getInitialState: function getInitialState() {\n\t    return undefined;\n\t  },\n\n\t  serialize: function serialize(state) {\n\t    return state;\n\t  },\n\n\t  deserialize: function deserialize() {\n\t    var state = arguments[0] === undefined ? this.getInitialState() : arguments[0];\n\n\t    return state;\n\t  },\n\n\t  toString: function toString() {\n\t    throw new Error(\"Stores must implement a toString() method\");\n\t  }\n\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * assert\n\t * If not true, throw an error\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = assert;\n\n\tfunction assert(bool, message) {\n\t  if (!bool) {\n\t    var error = new Error(message);\n\n\t    // Remove `assert` from the stack\n\t    error.framesToPop = 1;\n\n\t    throw error;\n\t  }\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\t/**\n\t * assign\n\t * Non-destructively assign one object into another\n\t */\n\n\tmodule.exports = assign;\n\n\tfunction assign(a, b) {\n\t  return _extends({}, a, b);\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _toArray = function (arr) { return Array.isArray(arr) ? arr : Array.from(arr); };\n\n\t/**\n\t * Install\n\t * A simple FIFO queue for installing plugins\n\t */\n\n\tmodule.exports = install;\n\n\tfunction install(_ref, app, callback) {\n\t  var _ref2 = _toArray(_ref);\n\n\t  var plugin = _ref2[0];\n\n\t  var tail = _ref2.slice(1);\n\n\t  if (!plugin) {\n\t    return callback();\n\t  }plugin.register(app, app._options, function (err) {\n\t    if (err) throw err;\n\t    install(tail, app, callback);\n\t  });\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Pulse\n\t * A singular event emitter. Pulse is simply the result of pumping\n\t * blood.\n\t *\n\t * This is a factory/decorator depending on usage. There are some\n\t * compression benefits to this, prevents the need to use super.\n\t */\n\n\t\"use strict\";\n\n\tfunction pulse() {\n\t  var infuse = arguments[0] === undefined ? {} : arguments[0];\n\n\t  var callbacks = [];\n\n\t  /**\n\t   * Given a CALLBACK function, remove it from the Set of callbacks.\n\t   * Throws an error if the callback is not included in the Set.\n\t   */\n\t  infuse.ignore = function (callback) {\n\t    callbacks = callbacks.filter(function (i) {\n\t      return i !== callback;\n\t    });\n\t  };\n\n\t  /**\n\t   * Given a CALLBACK function, add it to the Set of all callbacks.\n\t   */\n\t  infuse.listen = function (callback) {\n\t    callbacks.push(callback);\n\t  };\n\n\t  /**\n\t   * Trigger every callback in the Set\n\t   */\n\t  infuse.pump = function () {\n\t    /**\n\t     * Important: do not cache the length of _callbacks\n\t     * in the event a callback causes later subscriptions\n\t     * to disappear\n\t     */\n\t    for (var i = 0; i < callbacks.length; i++) {\n\t      callbacks[i].call(this);\n\t    }\n\t  };\n\n\t  return infuse;\n\t}\n\n\tmodule.exports = pulse;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * shallowEquals\n\t * A dead simple shallow equality check.\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = function (prev, next) {\n\t  for (var i in prev) {\n\t    if (prev[i] !== next[i]) return false;\n\t  }\n\n\t  for (var i in next) {\n\t    if (next[i] !== prev[i]) return false;\n\t  }\n\n\t  return true;\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\n\t/**\n\t * Tag\n\t * Given an object of methods, modify each method to\n\t * return a unique id when stringifyed\n\t */\n\n\tvar mapBy = _interopRequire(__webpack_require__(1));\n\n\tvar uid = 0;\n\n\tfunction isFunction(value) {\n\t  return typeof value === \"function\";\n\t}\n\n\tfunction decorate(fn, key) {\n\t  var copy = fn.bind(null);\n\t  var id = \"_\" + key + \"_\" + uid++;\n\n\t  copy.toString = function () {\n\t    return id;\n\t  };\n\n\t  return copy;\n\t}\n\n\tmodule.exports = function (actions) {\n\t  return mapBy(Object.keys(actions), function (key) {\n\t    var value = actions[key];\n\t    return isFunction(value) ? decorate(value, key) : value;\n\t  });\n\t};\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** Microcosm.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 80699a3847c97b7032ab\n **/","/**\n * Microcosm\n * An isomorphic flux implimentation. The strength of Microcosm\n * is that each application is its own fully encapsulated world\n */\n\nexport let tag = require('./tag')\nexport default require('./Microcosm')\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/*\n * MapBy\n * Take a list and reduce it into an object\n */\n\nexport default function mapBy (array, fn, initial={}) {\n  return array.reduce(function(memo, next) {\n    memo[next] = fn(next)\n    return memo\n  }, initial)\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/mapBy.js\n **/","/**\n * Microcosm\n * An isomorphic flux implementation. The strength of Microcosm\n * is that each application is its own fully encapsulated world\n */\n\nimport Store   from './Store'\nimport assert  from './assert'\nimport assign  from './assign'\nimport install from './install'\nimport isEqual from './shallowEquals'\nimport mapBy   from './mapBy'\nimport pulse   from './pulse'\n\nexport default class Microcosm {\n\n  constructor(options={}) {\n    pulse(this)\n\n    this._options = options\n    this._plugins = []\n    this._state   = this.getInitialState(options)\n    this._stores  = []\n  }\n\n  getInitialState() {\n    // Assigns the default state. Most of the time this will not need\n    // to be overridden, however if using something like ImmutableJS,\n    // you could return a different data structure here.\n    return {}\n  }\n\n  shouldUpdate(prev, next) {\n    // Whenever an action is dispatched, the resulting state\n    // modification will be diffed to identify if a change event\n    // should fire.\n    //\n    // The default strategy for determining that state has changed\n    // is a simple shallow equals check\n    return isEqual(prev, next) === false\n  }\n\n  has(key) {\n    // Does this instance of microcosm contain the given store?\n    // Important: Uses the unique identifier, not the object reference\n    return this._stores.some(store => `${key}` === `${store}`)\n  }\n\n  get(key) {\n    // How state should be retrieved. This function is useful to\n    // override with the particular method of retrieval for the data\n    // structure returned from `getInitialState`\n    return this._state[key]\n  }\n\n  swap(next) {\n    // Swap is basically a reset where the next state is the result of\n    // folding one object over the next\n    this.reset(assign(this._state, next))\n  }\n\n  reset(next) {\n    // Given a next state, only trigger an event if state actually changed\n    if (this.shouldUpdate(this._state, next)) {\n      this._state = next\n      this.pump()\n    }\n  }\n\n  prepare(fn, ...buffer) {\n    return this.send.bind(this, fn, ...buffer)\n  }\n\n  send(fn, ...params) {\n    const request = fn.apply(this, params)\n\n    // Actions some times return promises. When this happens, wait for\n    // them to resolve before moving on\n    if (request instanceof Promise) {\n      return request.then(body => this.dispatch(fn, body))\n    }\n\n    return this.dispatch(fn, request)\n  }\n\n  clone() {\n    return Object.create(this._state)\n  }\n\n  dispatch(action, body) {\n    let clone = this.clone()\n\n    // First get all stores that can repond to this action\n    const answerable = this._stores.filter(store => action in store)\n\n    // Next build the change set\n    const next = mapBy(answerable,\n                       store => store[action](clone[store], body),\n                       clone)\n\n    // Produce the next state by merging changes into the current state\n    this.reset(next)\n\n    // Send back the body to the original signaler\n    return body\n  }\n\n  addPlugin(plugin) {\n    assert('register' in plugin, 'Plugins must have a register method.')\n    this._plugins.push(plugin)\n  }\n\n  addStore(store) {\n    // Make sure life cycle methods are included\n    const safe = assign(Store, store)\n\n    // Don't reassign stores that are already included. Fail hard.\n    assert(!this.has(safe), `Tried to add \"${store}\" but it is not unique`)\n\n    // Add the validated stores to the list of known entities\n    this._stores.push(safe)\n  }\n\n  start(done) {\n    // Start by setting the initial state to the result of calling\n    // `getInitialState` on the microcosm and all of its stores\n    this._state = mapBy(this._stores,\n                        store => store.getInitialState(),\n                        this.getInitialState())\n\n    // Finally, queue plugins and then notify that installation has\n    // finished\n    install(this._plugins, this, done)\n  }\n\n  serialize() {\n    return mapBy(this._stores, store => store.serialize(this.get(store)))\n  }\n\n  deserialize(data={}) {\n    return mapBy(this._stores, store => store.deserialize(data[store]))\n  }\n\n  seed(data) {\n    // Tells the microcosm how it should handle data injected from\n    // sources.\n    //\n    // By default, it will clean the data with `deserialize` and\n    // then reset the existing data set with the new values\n    this.reset(this.deserialize(data))\n  }\n\n  toJSON() {\n    return this.serialize()\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Microcosm.js\n **/","export default {\n\n  getInitialState() {\n    return undefined\n  },\n\n  serialize(state) {\n    return state\n  },\n\n  deserialize(state = this.getInitialState()) {\n    return state\n  },\n\n  toString() {\n    throw new Error('Stores must implement a toString() method')\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Store.js\n **/","/**\n * assert\n * If not true, throw an error\n */\n\nexport default function assert (bool, message) {\n  if (!bool) {\n    const error = new Error(message)\n\n    // Remove `assert` from the stack\n    error.framesToPop = 1;\n\n    throw error\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/assert.js\n **/","/**\n * assign\n * Non-destructively assign one object into another\n */\n\nexport default function assign (a, b) {\n  return { ...a, ...b }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/assign.js\n **/","/**\n * Install\n * A simple FIFO queue for installing plugins\n */\n\nexport default function install ([plugin, ...tail], app, callback) {\n  if (!plugin) return callback()\n\n  plugin.register(app, app._options, function(err) {\n    if (err) throw err\n    install(tail, app, callback)\n  })\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/install.js\n **/","/**\n * Pulse\n * A singular event emitter. Pulse is simply the result of pumping\n * blood.\n *\n * This is a factory/decorator depending on usage. There are some\n * compression benefits to this, prevents the need to use super.\n */\n\nfunction pulse (infuse={}) {\n  let callbacks = []\n\n  /**\n   * Given a CALLBACK function, remove it from the Set of callbacks.\n   * Throws an error if the callback is not included in the Set.\n   */\n  infuse.ignore = function (callback) {\n    callbacks = callbacks.filter(i => i !== callback)\n  }\n\n  /**\n   * Given a CALLBACK function, add it to the Set of all callbacks.\n   */\n  infuse.listen = function (callback) {\n    callbacks.push(callback)\n  }\n\n  /**\n   * Trigger every callback in the Set\n   */\n  infuse.pump = function () {\n    /**\n     * Important: do not cache the length of _callbacks\n     * in the event a callback causes later subscriptions\n     * to disappear\n     */\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i].call(this)\n    }\n  }\n\n  return infuse\n}\n\nexport default pulse\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/pulse.js\n **/","/**\n * shallowEquals\n * A dead simple shallow equality check.\n */\n\nexport default function (prev, next) {\n  for (let i in prev) {\n    if (prev[i] !== next[i]) return false\n  }\n\n  for (let i in next) {\n    if (next[i] !== prev[i]) return false\n  }\n\n  return true\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/shallowEquals.js\n **/","/**\n * Tag\n * Given an object of methods, modify each method to\n * return a unique id when stringifyed\n */\n\nimport mapBy from './mapBy'\n\nlet uid = 0\n\nfunction isFunction (value) {\n  return typeof value === 'function'\n}\n\nfunction decorate (fn, key) {\n  const copy = fn.bind(null)\n  const id   = `_${ key }_${ uid++ }`\n\n  copy.toString = () => id\n\n  return copy\n}\n\nexport default actions => {\n  return mapBy(Object.keys(actions), function(key) {\n    const value = actions[key]\n    return isFunction(value) ? decorate(value, key) : value\n  })\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/tag.js\n **/"],"sourceRoot":""}