{"version":3,"sources":["Microcosm.js","webpack/bootstrap e276e73cf4c53ebeefd2","./src/index.js","./src/assert.js","./src/remap.js","./src/Action.js","./src/Microcosm.js","./src/Plugin.js","./src/Store.js","./src/clone.js","./src/getIn.js","./src/install.js","./src/pulse.js","./src/remapIf.js","./src/tag.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__esModule","tag","assert","bool","message","error","Error","framesToPop","remap","obj","transform","initial","undefined","arguments","keys","Object","reduce","memo","key","_interopRequire","_assert","validate","action","_extends","assign","target","i","length","source","prototype","hasOwnProperty","_classCallCheck","instance","Constructor","TypeError","_Action","Action","_Plugin","Plugin","_Store","Store","_clone","clone","_install","install","_pulse","pulse","_remap","_remapIf","remapIf","_getIn","getIn","Microcosm","this","_state","_stores","_plugins","push","signal","_this","_len","params","Array","_key","request","apply","Promise","then","body","_dispatch","pull","fn","args","val","concat","prepare","_push","buffer","bind","replace","data","_commit","deserialize","next","emit","actors","store","copy","staged","addPlugin","plugin","options","addStore","safe","serialize","toJSON","toObject","start","getInitialState","forEach","callback","state","toString","entity","create","shift","_ref","app","tail","slice","driver","register","err","infuse","callbacks","ignore","filter","listen","object","predicate","isFunction","value","decorate","uid","actions"],"mappings":"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","file":"Microcosm.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\t/**\n\t * Microcosm\n\t * An isomorphic flux implimentation. The strength of Microcosm\n\t * is that each application is its own fully encapsulated world\n\t */\n\n\tvar tag = __webpack_require__(12);\n\n\texports.tag = tag;\n\texports['default'] = __webpack_require__(4);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * assert\n\t * If not true, throw an error\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = assert;\n\n\tfunction assert(bool, message) {\n\t  if (!bool) {\n\t    var error = new Error(message);\n\n\t    // Remove `assert` from the stack\n\t    error.framesToPop = 1;\n\n\t    throw error;\n\t  }\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * remap\n\t * Take an object and assign new values onto another object\n\t * given a transformation function\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = remap;\n\n\tfunction remap(obj, transform) {\n\t  var initial = arguments[2] === undefined ? {} : arguments[2];\n\n\t  var keys = Object.keys(obj);\n\n\t  return keys.reduce(function (memo, key) {\n\t    memo[key] = transform(obj[key], key);\n\t    return memo;\n\t  }, initial);\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj['default'] : obj; };\n\n\t/**\n\t * Action\n\t * Helps to validate actions\n\t */\n\n\tvar _assert = __webpack_require__(1);\n\n\tvar assert = _interopRequire(_assert);\n\n\tmodule.exports = {\n\n\t  validate: function validate(action) {\n\t    assert(typeof action === 'function', 'Action ' + action + ' is not callable, actions should be functions');\n\t  }\n\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj['default'] : obj; };\n\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\n\t/**\n\t * Microcosm\n\t * An isomorphic flux implementation. The strength of Microcosm\n\t * is that each application is its own fully encapsulated world.\n\t */\n\n\tvar _Action = __webpack_require__(3);\n\n\tvar Action = _interopRequire(_Action);\n\n\tvar _Plugin = __webpack_require__(5);\n\n\tvar Plugin = _interopRequire(_Plugin);\n\n\tvar _Store = __webpack_require__(6);\n\n\tvar Store = _interopRequire(_Store);\n\n\tvar _assert = __webpack_require__(1);\n\n\tvar assert = _interopRequire(_assert);\n\n\tvar _clone = __webpack_require__(7);\n\n\tvar clone = _interopRequire(_clone);\n\n\tvar _install = __webpack_require__(9);\n\n\tvar install = _interopRequire(_install);\n\n\tvar _pulse = __webpack_require__(10);\n\n\tvar pulse = _interopRequire(_pulse);\n\n\tvar _remap = __webpack_require__(2);\n\n\tvar remap = _interopRequire(_remap);\n\n\tvar _remapIf = __webpack_require__(11);\n\n\tvar remapIf = _interopRequire(_remapIf);\n\n\tvar _getIn = __webpack_require__(8);\n\n\tvar getIn = _interopRequire(_getIn);\n\n\tvar Microcosm = (function () {\n\t  function Microcosm() {\n\t    _classCallCheck(this, Microcosm);\n\n\t    pulse(this);\n\n\t    this._state = {};\n\t    this._stores = {};\n\t    this._plugins = [];\n\t  }\n\n\t  Microcosm.prototype.push = function push(signal) {\n\t    var _this = this;\n\n\t    for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      params[_key - 1] = arguments[_key];\n\t    }\n\n\t    Action.validate(signal);\n\n\t    var request = signal.apply(undefined, params);\n\n\t    // Actions some times return promises. When this happens, wait for\n\t    // them to resolve before moving on\n\t    if (request instanceof Promise) {\n\t      return request.then(function (body) {\n\t        return _this._dispatch(signal, body);\n\t      });\n\t    }\n\n\t    return this._dispatch(signal, request);\n\t  };\n\n\t  Microcosm.prototype.pull = function pull(key, fn) {\n\t    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t      args[_key - 2] = arguments[_key];\n\t    }\n\n\t    var val = getIn(this._state, key);\n\t    return typeof fn === 'function' ? fn.call.apply(fn, [this, val].concat(args)) : val;\n\t  };\n\n\t  Microcosm.prototype.prepare = function prepare(fn) {\n\t    var _push;\n\n\t    for (var _len = arguments.length, buffer = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      buffer[_key - 1] = arguments[_key];\n\t    }\n\n\t    Action.validate(fn);\n\t    return (_push = this.push).bind.apply(_push, [this, fn].concat(buffer));\n\t  };\n\n\t  Microcosm.prototype.replace = function replace(data) {\n\t    this._commit(this.deserialize(data));\n\t  };\n\n\t  Microcosm.prototype._commit = function _commit(next) {\n\t    this._state = next;\n\t    this.emit();\n\t  };\n\n\t  Microcosm.prototype._dispatch = function _dispatch(action, body) {\n\t    var _this = this;\n\n\t    var actors = remapIf(this._stores, function (store) {\n\t      return action in store;\n\t    });\n\n\t    if (Object.keys(actors).length > 0) {\n\t      (function () {\n\t        var copy = clone(_this._state);\n\t        var staged = remap(actors, function (store) {\n\t          return store[action](copy[store], body);\n\t        }, copy);\n\n\t        _this._commit(staged);\n\t      })();\n\t    }\n\n\t    return body;\n\t  };\n\n\t  Microcosm.prototype.addPlugin = function addPlugin(plugin, options) {\n\t    Plugin.validate(plugin);\n\n\t    this._plugins.push([plugin, options]);\n\t  };\n\n\t  Microcosm.prototype.addStore = function addStore(store) {\n\t    // Make sure life cycle methods are included\n\t    var safe = _extends({}, Store, store);\n\n\t    // Don't reassign stores that are already included. Fail hard.\n\t    assert(!this._stores[store], 'Tried to add \"' + store + '\" but it is not unique');\n\n\t    // Add the validated stores to the list of known entities\n\t    this._stores[safe] = safe;\n\t  };\n\n\t  Microcosm.prototype.serialize = function serialize() {\n\t    var _this = this;\n\n\t    return remap(this._stores, function (store) {\n\t      return store.serialize(_this.pull(store));\n\t    });\n\t  };\n\n\t  Microcosm.prototype.deserialize = function deserialize() {\n\t    var data = arguments[0] === undefined ? {} : arguments[0];\n\n\t    return remap(this._stores, function (store) {\n\t      return store.deserialize(data[store]);\n\t    });\n\t  };\n\n\t  Microcosm.prototype.toJSON = function toJSON() {\n\t    return this.serialize();\n\t  };\n\n\t  Microcosm.prototype.toObject = function toObject() {\n\t    return remapIf(this._state, function () {\n\t      return true;\n\t    });\n\t  };\n\n\t  Microcosm.prototype.start = function start() {\n\t    for (var _len = arguments.length, next = Array(_len), _key = 0; _key < _len; _key++) {\n\t      next[_key] = arguments[_key];\n\t    }\n\n\t    // Start by producing the initial state\n\t    this._state = remap(this._stores, function (store) {\n\t      return store.getInitialState();\n\t    });\n\n\t    // Queue plugins and then notify that installation has finished\n\t    install(this._plugins, this, function () {\n\t      next.forEach(function (callback) {\n\t        return callback();\n\t      });\n\t    });\n\t  };\n\n\t  return Microcosm;\n\t})();\n\n\tmodule.exports = Microcosm;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj['default'] : obj; };\n\n\t/**\n\t * Plugin\n\t * Helps to validate plugins\n\t */\n\n\tvar _assert = __webpack_require__(1);\n\n\tvar assert = _interopRequire(_assert);\n\n\tmodule.exports = {\n\n\t  validate: function validate(plugin) {\n\t    assert('register' in plugin, 'Plugins must have a register method.');\n\t  }\n\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tmodule.exports = {\n\n\t  getInitialState: function getInitialState() {\n\t    return undefined;\n\t  },\n\n\t  serialize: function serialize(state) {\n\t    return state;\n\t  },\n\n\t  deserialize: function deserialize() {\n\t    var state = arguments[0] === undefined ? this.getInitialState() : arguments[0];\n\n\t    return state;\n\t  },\n\n\t  toString: function toString() {\n\t    throw new Error('Stores must implement a toString() method');\n\t  }\n\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * clone\n\t * A generalized shallow clone method\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = function (entity) {\n\t  return Object.create(entity);\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * getIn\n\t * Enumerate through a list of keys to get a value\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = getIn;\n\n\tfunction getIn(target, key) {\n\t  var keys = [].concat(key);\n\n\t  while (keys.length) {\n\t    target = target[\"\" + keys.shift()];\n\t  }\n\n\t  return target;\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Install\n\t * A simple FIFO queue for installing plugins\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = install;\n\n\tfunction install(_ref, app, callback) {\n\t  var plugin = _ref[0];\n\n\t  var tail = _ref.slice(1);\n\n\t  if (!plugin) {\n\t    return callback();\n\t  }var driver = plugin[0];\n\t  var options = plugin[1];\n\n\t  driver.register(app, options, function (err) {\n\t    if (err) throw err;\n\t    install(tail, app, callback);\n\t  });\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Pulse\n\t * A singular event emitter. Pulse is simply the result of pulseing\n\t * blood.\n\t *\n\t * This is a factory/decorator depending on usage. There are some\n\t * compression benefits to this, prevents the need to use super.\n\t */\n\n\t\"use strict\";\n\n\tfunction pulse() {\n\t  var infuse = arguments[0] === undefined ? {} : arguments[0];\n\n\t  var callbacks = [];\n\n\t  /**\n\t   * Given a CALLBACK function, remove it from the Set of callbacks.\n\t   * Throws an error if the callback is not included in the Set.\n\t   */\n\t  infuse.ignore = function (callback) {\n\t    callbacks = callbacks.filter(function (i) {\n\t      return i !== callback;\n\t    });\n\t  };\n\n\t  /**\n\t   * Given a CALLBACK function, add it to the Set of all callbacks.\n\t   */\n\t  infuse.listen = function (callback) {\n\t    callbacks.push(callback);\n\t  };\n\n\t  /**\n\t   * Trigger every callback in the Set\n\t   */\n\t  infuse.emit = function () {\n\t    /**\n\t     * Important: do not cache the length of _callbacks\n\t     * in the event a callback causes later subscriptions\n\t     * to disappear\n\t     */\n\t    for (var i = 0; i < callbacks.length; i++) {\n\t      callbacks[i].call(this);\n\t    }\n\t  };\n\n\t  return infuse;\n\t}\n\n\tmodule.exports = pulse;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * RemapIf\n\t * Remap wanted keys from an object\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = function (object, predicate) {\n\t  var copy = {};\n\n\t  for (var i in object) {\n\t    if (predicate(object[i])) {\n\t      copy[i] = object[i];\n\t    }\n\t  }\n\n\t  return copy;\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj['default'] : obj; };\n\n\t/**\n\t * Tag\n\t * Given an object of methods, modify each method to\n\t * return a unique id when stringifyed\n\t */\n\n\tvar _remap = __webpack_require__(2);\n\n\tvar remap = _interopRequire(_remap);\n\n\tvar uid = 0;\n\n\tfunction isFunction(value) {\n\t  return typeof value === 'function';\n\t}\n\n\tfunction decorate(fn, key) {\n\t  var copy = fn.bind(null);\n\t  var id = '_' + key + '_' + uid++;\n\n\t  copy.toString = function () {\n\t    return id;\n\t  };\n\n\t  return copy;\n\t}\n\n\tmodule.exports = function (actions) {\n\t  return remap(actions, function (value, key) {\n\t    return isFunction(value) ? decorate(value, key) : value;\n\t  });\n\t};\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** Microcosm.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e276e73cf4c53ebeefd2\n **/","/**\n * Microcosm\n * An isomorphic flux implimentation. The strength of Microcosm\n * is that each application is its own fully encapsulated world\n */\n\nexport let tag = require('./tag')\n\nexport default require('./Microcosm')\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/**\n * assert\n * If not true, throw an error\n */\n\nexport default function assert (bool, message) {\n  if (!bool) {\n    const error = new Error(message)\n\n    // Remove `assert` from the stack\n    error.framesToPop = 1;\n\n    throw error\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/assert.js\n **/","/*\n * remap\n * Take an object and assign new values onto another object\n * given a transformation function\n */\n\nexport default function remap (obj, transform, initial={}) {\n  let keys = Object.keys(obj)\n\n  return keys.reduce(function(memo, key) {\n    memo[key] = transform(obj[key], key)\n    return memo\n  }, initial)\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/remap.js\n **/","/**\n * Action\n * Helps to validate actions\n */\n\nimport assert from './assert'\n\nexport default {\n\n  validate(action) {\n    assert(typeof action === 'function', `Action ${ action } is not callable, actions should be functions`)\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Action.js\n **/","/**\n * Microcosm\n * An isomorphic flux implementation. The strength of Microcosm\n * is that each application is its own fully encapsulated world.\n */\n\nimport Action  from './Action'\nimport Plugin  from './Plugin'\nimport Store   from './Store'\nimport assert  from './assert'\nimport clone   from './clone'\nimport install from './install'\nimport pulse   from './pulse'\nimport remap   from './remap'\nimport remapIf from './remapIf'\nimport getIn   from './getIn'\n\nexport default class Microcosm {\n\n  constructor() {\n    pulse(this)\n\n    this._state   = {}\n    this._stores  = {}\n    this._plugins = []\n  }\n\n  push(signal, ...params) {\n    Action.validate(signal)\n\n    const request = signal(...params)\n\n    // Actions some times return promises. When this happens, wait for\n    // them to resolve before moving on\n    if (request instanceof Promise) {\n      return request.then(body => this._dispatch(signal, body))\n    }\n\n    return this._dispatch(signal, request)\n  }\n\n  pull(key, fn, ...args) {\n    let val = getIn(this._state, key)\n    return typeof fn === 'function' ? fn.call(this, val, ...args) : val\n  }\n\n  prepare(fn, ...buffer) {\n    Action.validate(fn)\n    return this.push.bind(this, fn, ...buffer)\n  }\n\n  replace(data) {\n    this._commit(this.deserialize(data))\n  }\n\n  _commit(next) {\n    this._state = next\n    this.emit()\n  }\n\n  _dispatch(action, body) {\n    let actors = remapIf(this._stores, store => action in store)\n\n    if (Object.keys(actors).length > 0) {\n      let copy   = clone(this._state)\n      let staged = remap(actors, store => store[action](copy[store], body), copy)\n\n      this._commit(staged)\n    }\n\n    return body\n  }\n\n  addPlugin(plugin, options) {\n    Plugin.validate(plugin)\n\n    this._plugins.push([ plugin, options ])\n  }\n\n  addStore(store) {\n    // Make sure life cycle methods are included\n    const safe = { ...Store, ...store }\n\n    // Don't reassign stores that are already included. Fail hard.\n    assert(!this._stores[store], `Tried to add \"${store}\" but it is not unique`)\n\n    // Add the validated stores to the list of known entities\n    this._stores[safe] = safe\n  }\n\n  serialize() {\n    return remap(this._stores, store => store.serialize(this.pull(store)))\n  }\n\n  deserialize(data={}) {\n    return remap(this._stores, store => store.deserialize(data[store]))\n  }\n\n  toJSON() {\n    return this.serialize()\n  }\n\n  toObject() {\n    return remapIf(this._state, () => true)\n  }\n\n  start(...next) {\n    // Start by producing the initial state\n    this._state = remap(this._stores, store => store.getInitialState())\n\n    // Queue plugins and then notify that installation has finished\n    install(this._plugins, this, function() {\n      next.forEach(callback => callback())\n    })\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Microcosm.js\n **/","/**\n * Plugin\n * Helps to validate plugins\n */\n\nimport assert from './assert'\n\nexport default {\n\n  validate(plugin) {\n    assert('register' in plugin, 'Plugins must have a register method.')\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Plugin.js\n **/","export default {\n\n  getInitialState() {\n    return undefined\n  },\n\n  serialize(state) {\n    return state\n  },\n\n  deserialize(state = this.getInitialState()) {\n    return state\n  },\n\n  toString() {\n    throw new Error('Stores must implement a toString() method')\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Store.js\n **/","/**\n * clone\n * A generalized shallow clone method\n */\n\nexport default function (entity) {\n  return Object.create(entity)\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/clone.js\n **/","/**\n * getIn\n * Enumerate through a list of keys to get a value\n */\n\nexport default function getIn (target, key) {\n  let keys = [].concat(key)\n\n  while(keys.length) {\n    target = target[`${keys.shift()}`]\n  }\n\n  return target\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/getIn.js\n **/","/**\n * Install\n * A simple FIFO queue for installing plugins\n */\n\nexport default function install ([plugin, ...tail], app, callback) {\n  if (!plugin) return callback()\n\n  let [ driver, options ] = plugin\n\n  driver.register(app, options, function(err) {\n    if (err) throw err\n    install(tail, app, callback)\n  })\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/install.js\n **/","/**\n * Pulse\n * A singular event emitter. Pulse is simply the result of pulseing\n * blood.\n *\n * This is a factory/decorator depending on usage. There are some\n * compression benefits to this, prevents the need to use super.\n */\n\nfunction pulse (infuse={}) {\n  let callbacks = []\n\n  /**\n   * Given a CALLBACK function, remove it from the Set of callbacks.\n   * Throws an error if the callback is not included in the Set.\n   */\n  infuse.ignore = function (callback) {\n    callbacks = callbacks.filter(i => i !== callback)\n  }\n\n  /**\n   * Given a CALLBACK function, add it to the Set of all callbacks.\n   */\n  infuse.listen = function (callback) {\n    callbacks.push(callback)\n  }\n\n  /**\n   * Trigger every callback in the Set\n   */\n  infuse.emit = function () {\n    /**\n     * Important: do not cache the length of _callbacks\n     * in the event a callback causes later subscriptions\n     * to disappear\n     */\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i].call(this)\n    }\n  }\n\n  return infuse\n}\n\nexport default pulse\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/pulse.js\n **/","/**\n * RemapIf\n * Remap wanted keys from an object\n */\n\nexport default function (object, predicate) {\n  let copy = {}\n\n  for (var i in object) {\n    if (predicate(object[i])) {\n      copy[i] = object[i]\n    }\n  }\n\n  return copy\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/remapIf.js\n **/","/**\n * Tag\n * Given an object of methods, modify each method to\n * return a unique id when stringifyed\n */\n\nimport remap from './remap'\n\nlet uid = 0\n\nfunction isFunction (value) {\n  return typeof value === 'function'\n}\n\nfunction decorate (fn, key) {\n  const copy = fn.bind(null)\n  const id   = `_${ key }_${ uid++ }`\n\n  copy.toString = () => id\n\n  return copy\n}\n\nexport default actions => {\n  return remap(actions, function(value, key) {\n    return isFunction(value) ? decorate(value, key) : value\n  })\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/tag.js\n **/"],"sourceRoot":""}