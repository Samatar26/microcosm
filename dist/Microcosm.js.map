{"version":3,"sources":["Microcosm.js","webpack/bootstrap 95d167136d79fd69d9f7","./src/index.js","./src/Heartbeat.js","./src/Microcosm.js","./src/Store.js","./src/tag.js","./~/is-equal-shallow/index.js","./~/is-equal-shallow/~/is-primitive/index.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__esModule","tag","_classCallCheck","instance","Constructor","TypeError","Heartbeat","this","_callbacks","prototype","ignore","callback","filter","i","listen","concat","pump","length","_interopRequire","obj","_extends","Object","assign","target","arguments","source","key","hasOwnProperty","_inherits","subClass","superClass","create","constructor","value","enumerable","writable","configurable","__proto__","Store","isEqual","Microcosm","_Heartbeat","_stores","_state","getInitialState","shouldUpdate","prev","next","seed","data","swap","deserialize","has","_this","_len","stores","Array","_key","some","a","b","set","_extends2","get","prepare","fn","_send","buffer","send","bind","apply","params","request","Promise","then","body","dispatch","action","answerable","store","changes","reduce","state","addStore","safe","map","Error","join","forEach","serialize","memo","toJSON","undefined","toString","uid","isFunction","decorate","copy","actions","keys","isPrimitive"],"mappings":"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","file":"Microcosm.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports.__esModule = true;\n\t/**\n\t * Microcosm\n\t * An isomorphic flux implimentation. The strength of Microcosm\n\t * is that each application is its own fully encapsulated world\n\t */\n\n\tvar tag = __webpack_require__(4);\n\texports.tag = tag;\n\texports[\"default\"] = __webpack_require__(2);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n\t/**\n\t * Heartbeat\n\t * A singular event emitter. Heartbeat simply pumps blood.\n\t */\n\n\tvar Heartbeat = (function () {\n\t  function Heartbeat() {\n\t    _classCallCheck(this, Heartbeat);\n\n\t    this._callbacks = [];\n\t  }\n\n\t  /**\n\t   * Given a CALLBACK function, remove it from the Set of callbacks.\n\t   * Throws an error if the callback is not included in the Set.\n\t   */\n\n\t  Heartbeat.prototype.ignore = function ignore(callback) {\n\t    this._callbacks = this._callbacks.filter(function (i) {\n\t      return i !== callback;\n\t    });\n\t  };\n\n\t  /**\n\t   * Given a CALLBACK function, add it to the Set of all callbacks.\n\t   */\n\n\t  Heartbeat.prototype.listen = function listen(callback) {\n\t    this._callbacks = this._callbacks.concat(callback);\n\t  };\n\n\t  /**\n\t   * Trigger every callback in the Set\n\t   */\n\n\t  Heartbeat.prototype.pump = function pump() {\n\t    /**\n\t     * Important: do not cache the length of _callbacks\n\t     * in the event a callback causes later subscriptions\n\t     * to disappear\n\t     */\n\t    for (var i = 0; i < this._callbacks.length; i++) {\n\t      this._callbacks[i].call(this);\n\t    }\n\t  };\n\n\t  return Heartbeat;\n\t})();\n\n\tmodule.exports = Heartbeat;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\tvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n\t/**\n\t * Microcosm\n\t * An isomorphic flux implimentation. The strength of Microcosm\n\t * is that each application is its own fully encapsulated world\n\t */\n\n\tvar Heartbeat = _interopRequire(__webpack_require__(1));\n\n\tvar Store = _interopRequire(__webpack_require__(3));\n\n\tvar isEqual = _interopRequire(__webpack_require__(5));\n\n\tvar Microcosm = (function (_Heartbeat) {\n\t  function Microcosm() {\n\t    _classCallCheck(this, Microcosm);\n\n\t    _Heartbeat.call(this);\n\n\t    this._stores = [];\n\t    this._state = this.getInitialState();\n\t  }\n\n\t  _inherits(Microcosm, _Heartbeat);\n\n\t  Microcosm.prototype.getInitialState = function getInitialState() {\n\t    // Assigns the default state. Most of the time this will not need\n\t    // to be overridden, however if using something like ImmutableJS,\n\t    // you could return a different data structure here.\n\t    return {};\n\t  };\n\n\t  Microcosm.prototype.shouldUpdate = function shouldUpdate(prev, next) {\n\t    // Whenever an action is dispatched, the resulting state\n\t    // modification will be diffed to identify if a change event\n\t    // should fire.\n\t    //\n\t    // The default strategy for determining that state has changed\n\t    // is a simple shallow equals check\n\t    return isEqual(prev, next) == false;\n\t  };\n\n\t  Microcosm.prototype.seed = function seed(data) {\n\t    // Tells the microcosm how it should handle data injected from\n\t    // sources.\n\t    //\n\t    // By default, it will clean the data with `deserialize` and\n\t    // then override the existing data set with the new values\n\t    this.swap(this.deserialize(data));\n\t  };\n\n\t  Microcosm.prototype.swap = function swap(next) {\n\t    // Given a next state, only trigger an event if state actually changed\n\t    if (this.shouldUpdate(this._state, next)) {\n\t      this._state = next;\n\t      this.pump();\n\t    }\n\t  };\n\n\t  Microcosm.prototype.has = function has() {\n\t    var _this = this;\n\n\t    for (var _len = arguments.length, stores = Array(_len), _key = 0; _key < _len; _key++) {\n\t      stores[_key] = arguments[_key];\n\t    }\n\n\t    return stores.some(function (a) {\n\t      return _this._stores.some(function (b) {\n\t        return \"\" + a === \"\" + b;\n\t      });\n\t    });\n\t  };\n\n\t  Microcosm.prototype.set = function set(key, value) {\n\t    // How state should be re-assigned. This function is useful to\n\t    // override with the particular method of assignment for the data\n\t    // structure returned from `getInitialState`\n\t    this._state = _extends({}, this._state, (function () {\n\t      var _extends2 = {};\n\t      _extends2[key] = value;\n\t      return _extends2;\n\t    })());\n\t  };\n\n\t  Microcosm.prototype.get = function get(key) {\n\t    // How state should be retrieved. This function is useful to\n\t    // override with the particular method of retrieval for the data\n\t    // structure returned from `getInitialState`\n\t    return this._state[key];\n\t  };\n\n\t  Microcosm.prototype.prepare = function prepare(fn) {\n\t    var _send;\n\n\t    for (var _len = arguments.length, buffer = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      buffer[_key - 1] = arguments[_key];\n\t    }\n\n\t    return (_send = this.send).bind.apply(_send, [this, fn].concat(buffer));\n\t  };\n\n\t  Microcosm.prototype.send = function send(fn) {\n\t    var _this = this;\n\n\t    for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      params[_key - 1] = arguments[_key];\n\t    }\n\n\t    var request = fn.apply(this, params);\n\n\t    // Actions some times return promises. When this happens, wait for\n\t    // them to resolve before moving on\n\t    if (request instanceof Promise) {\n\t      return request.then(function (body) {\n\t        return _this.dispatch(fn, body);\n\t      });\n\t    }\n\n\t    return this.dispatch(fn, request);\n\t  };\n\n\t  Microcosm.prototype.dispatch = function dispatch(action, body) {\n\t    var _this = this;\n\n\t    // First get all stores that can repond to this action\n\t    var answerable = this._stores.filter(function (store) {\n\t      return action in store;\n\t    });\n\n\t    // Next build the change set\n\t    var changes = answerable.reduce(function (state, store) {\n\t      state[store] = store[action](_this.get(store), body);\n\t      return state;\n\t    }, {});\n\n\t    // Produce the next state by folding changes into the current state\n\t    this.swap(_extends({}, this._state, changes));\n\n\t    // Send back the body to the original signaler\n\t    return body;\n\t  };\n\n\t  Microcosm.prototype.addStore = function addStore() {\n\t    var _this = this;\n\n\t    for (var _len = arguments.length, stores = Array(_len), _key = 0; _key < _len; _key++) {\n\t      stores[_key] = arguments[_key];\n\t    }\n\n\t    // Make sure that the Store implements important life cycle methods\n\t    var safe = stores.map(function (store) {\n\t      return _extends({}, Store, store);\n\t    });\n\n\t    // Don't reassign stores that are already included\n\t    // fail hard\n\t    if (this.has(safe)) {\n\t      throw Error(\"A toString method within \\\"\" + stores.join(\", \") + \"\\\" is not unique\");\n\t    }\n\n\t    // Once verified, setup initial state\n\t    safe.forEach(function (store) {\n\t      return _this.set(store, store.getInitialState());\n\t    });\n\n\t    this._stores = this._stores.concat(safe);\n\t  };\n\n\t  Microcosm.prototype.serialize = function serialize() {\n\t    var _this = this;\n\n\t    return this._stores.reduce(function (memo, store) {\n\t      memo[store] = store.serialize(_this.get(store));\n\t      return memo;\n\t    }, {});\n\t  };\n\n\t  Microcosm.prototype.deserialize = function deserialize(data) {\n\t    return this._stores.reduce(function (memo, store) {\n\t      memo[store] = store.deserialize(data[store]);\n\t      return memo;\n\t    }, {});\n\t  };\n\n\t  Microcosm.prototype.toJSON = function toJSON() {\n\t    return this.serialize();\n\t  };\n\n\t  return Microcosm;\n\t})(Heartbeat);\n\n\tmodule.exports = Microcosm;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tmodule.exports = {\n\n\t  getInitialState: function getInitialState() {\n\t    return undefined;\n\t  },\n\n\t  serialize: function serialize(state) {\n\t    return state;\n\t  },\n\n\t  deserialize: function deserialize() {\n\t    var state = arguments[0] === undefined ? this.getInitialState() : arguments[0];\n\n\t    return state;\n\t  },\n\n\t  toString: function toString() {\n\t    throw new Error(\"Stores must implement a toString() method\");\n\t  }\n\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Tag\n\t * Given an object of methods, modify each method to\n\t * return a unique id when stringifyed\n\t */\n\n\t\"use strict\";\n\n\tvar uid = 0;\n\n\tvar isFunction = function (value) {\n\t  return typeof value === \"function\";\n\t};\n\n\tvar decorate = function (fn, key) {\n\t  var copy = fn.bind(null);\n\t  var id = \"_\" + key + \"_\" + uid++;\n\n\t  copy.toString = function () {\n\t    return id;\n\t  };\n\n\t  return copy;\n\t};\n\n\tmodule.exports = function (actions) {\n\t  var keys = Object.keys(actions);\n\n\t  return keys.reduce(function (memo, key) {\n\t    var value = actions[key];\n\n\t    memo[key] = isFunction(value) ? decorate(value, key) : value;\n\n\t    return memo;\n\t  }, {});\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * is-equal-shallow <https://github.com/jonschlinkert/is-equal-shallow>\n\t *\n\t * Copyright (c) 2015, Jon Schlinkert.\n\t * Licensed under the MIT License.\n\t */\n\n\t'use strict';\n\n\tvar isPrimitive = __webpack_require__(6);\n\n\tmodule.exports = function isEqual(a, b) {\n\t  if (!a && !b) { return true; }\n\t  if (!a && b || a && !b) { return false; }\n\n\t  for (var key in b) {\n\t    if (!isPrimitive(b[key]) || !a.hasOwnProperty(key) || (a[key] !== b[key])) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * is-primitive <https://github.com/jonschlinkert/is-primitive>\n\t *\n\t * Copyright (c) 2014 Jon Schlinkert, contributors.\n\t * Licensed under the MIT License\n\t */\n\n\t'use strict';\n\n\t// see http://jsperf.com/testing-value-is-primitive/5\n\tmodule.exports = function isPrimitive(value) {\n\t  switch (typeof value) {\n\t    case \"string\":\n\t    case \"number\":\n\t    case \"boolean\":\n\t    case \"symbol\":\n\t      return true;\n\t    }\n\n\t  return value == null;\n\t};\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** Microcosm.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 95d167136d79fd69d9f7\n **/","/**\n * Microcosm\n * An isomorphic flux implimentation. The strength of Microcosm\n * is that each application is its own fully encapsulated world\n */\n\nexport let tag = require('./tag')\nexport default require('./Microcosm')\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/**\n * Heartbeat\n * A singular event emitter. Heartbeat simply pumps blood.\n */\n\nexport default class Heartbeat {\n\n  constructor() {\n    this._callbacks = []\n  }\n\n  /**\n   * Given a CALLBACK function, remove it from the Set of callbacks.\n   * Throws an error if the callback is not included in the Set.\n   */\n  ignore(callback) {\n    this._callbacks = this._callbacks.filter(i => i !== callback)\n  }\n\n  /**\n   * Given a CALLBACK function, add it to the Set of all callbacks.\n   */\n  listen(callback) {\n    this._callbacks = this._callbacks.concat(callback)\n  }\n\n  /**\n   * Trigger every callback in the Set\n   */\n  pump() {\n    /**\n     * Important: do not cache the length of _callbacks\n     * in the event a callback causes later subscriptions\n     * to disappear\n     */\n    for (var i = 0; i < this._callbacks.length; i++) {\n      this._callbacks[i].call(this)\n    }\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Heartbeat.js\n **/","/**\n * Microcosm\n * An isomorphic flux implimentation. The strength of Microcosm\n * is that each application is its own fully encapsulated world\n */\n\nimport Heartbeat from './Heartbeat'\nimport Store     from './Store'\nimport isEqual   from 'is-equal-shallow'\n\nexport default class Microcosm extends Heartbeat {\n\n  constructor() {\n    super()\n\n    this._stores = []\n    this._state  = this.getInitialState()\n  }\n\n  getInitialState() {\n    // Assigns the default state. Most of the time this will not need\n    // to be overridden, however if using something like ImmutableJS,\n    // you could return a different data structure here.\n    return {}\n  }\n\n  shouldUpdate(prev, next) {\n    // Whenever an action is dispatched, the resulting state\n    // modification will be diffed to identify if a change event\n    // should fire.\n    //\n    // The default strategy for determining that state has changed\n    // is a simple shallow equals check\n    return isEqual(prev, next) == false\n  }\n\n  seed(data) {\n    // Tells the microcosm how it should handle data injected from\n    // sources.\n    //\n    // By default, it will clean the data with `deserialize` and\n    // then override the existing data set with the new values\n    this.swap(this.deserialize(data))\n  }\n\n  swap(next) {\n    // Given a next state, only trigger an event if state actually changed\n    if (this.shouldUpdate(this._state, next)) {\n      this._state = next\n      this.pump()\n    }\n  }\n\n  has(...stores) {\n    return stores.some(a => this._stores.some(b => `${a}` === `${b}`))\n  }\n\n  set(key, value) {\n    // How state should be re-assigned. This function is useful to\n    // override with the particular method of assignment for the data\n    // structure returned from `getInitialState`\n    this._state = { ...this._state, [key]: value }\n  }\n\n  get(key) {\n    // How state should be retrieved. This function is useful to\n    // override with the particular method of retrieval for the data\n    // structure returned from `getInitialState`\n    return this._state[key]\n  }\n\n  prepare(fn, ...buffer) {\n    return this.send.bind(this, fn, ...buffer)\n  }\n\n  send(fn, ...params) {\n    let request = fn.apply(this, params)\n\n    // Actions some times return promises. When this happens, wait for\n    // them to resolve before moving on\n    if (request instanceof Promise) {\n      return request.then(body => this.dispatch(fn, body))\n    }\n\n    return this.dispatch(fn, request)\n  }\n\n  dispatch(action, body) {\n    // First get all stores that can repond to this action\n    let answerable = this._stores.filter(store => action in store)\n\n    // Next build the change set\n    let changes = answerable.reduce((state, store) => {\n      state[store] = store[action](this.get(store), body)\n      return state\n    }, {})\n\n    // Produce the next state by folding changes into the current state\n    this.swap({ ...this._state, ...changes })\n\n    // Send back the body to the original signaler\n    return body\n  }\n\n  addStore(...stores) {\n    // Make sure that the Store implements important life cycle methods\n    let safe = stores.map(store => {\n      return { ...Store, ...store }\n    })\n\n    // Don't reassign stores that are already included\n    // fail hard\n    if (this.has(safe)) {\n      throw Error(`A toString method within \"${stores.join(', ')}\" is not unique`)\n    }\n\n    // Once verified, setup initial state\n    safe.forEach(store => this.set(store, store.getInitialState()))\n\n    this._stores = this._stores.concat(safe)\n  }\n\n  serialize() {\n    return this._stores.reduce((memo, store) => {\n      memo[store] = store.serialize(this.get(store))\n      return memo\n    }, {})\n  }\n\n  deserialize(data) {\n    return this._stores.reduce(function(memo, store) {\n      memo[store] = store.deserialize(data[store])\n      return memo\n    }, {})\n  }\n\n  toJSON() {\n    return this.serialize()\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Microcosm.js\n **/","export default {\n\n  getInitialState() {\n    return undefined\n  },\n\n  serialize(state) {\n    return state\n  },\n\n  deserialize(state = this.getInitialState()) {\n    return state\n  },\n\n  toString() {\n    throw new Error('Stores must implement a toString() method')\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Store.js\n **/","/**\n * Tag\n * Given an object of methods, modify each method to\n * return a unique id when stringifyed\n */\n\nlet uid = 0\n\nlet isFunction = value => typeof value === 'function'\n\nlet decorate = (fn, key) => {\n  let copy = fn.bind(null)\n  let id   = `_${ key }_${ uid++ }`\n\n  copy.toString = () => id\n\n  return copy\n}\n\nexport default actions => {\n  let keys = Object.keys(actions)\n\n  return keys.reduce((memo, key) => {\n    let value = actions[key]\n\n    memo[key] = isFunction(value) ? decorate(value, key) : value\n\n    return memo\n  }, {})\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/tag.js\n **/","/*!\n * is-equal-shallow <https://github.com/jonschlinkert/is-equal-shallow>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar isPrimitive = require('is-primitive');\n\nmodule.exports = function isEqual(a, b) {\n  if (!a && !b) { return true; }\n  if (!a && b || a && !b) { return false; }\n\n  for (var key in b) {\n    if (!isPrimitive(b[key]) || !a.hasOwnProperty(key) || (a[key] !== b[key])) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/is-equal-shallow/index.js\n ** module id = 5\n ** module chunks = 0\n **/","/*!\n * is-primitive <https://github.com/jonschlinkert/is-primitive>\n *\n * Copyright (c) 2014 Jon Schlinkert, contributors.\n * Licensed under the MIT License\n */\n\n'use strict';\n\n// see http://jsperf.com/testing-value-is-primitive/5\nmodule.exports = function isPrimitive(value) {\n  switch (typeof value) {\n    case \"string\":\n    case \"number\":\n    case \"boolean\":\n    case \"symbol\":\n      return true;\n    }\n\n  return value == null;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/is-equal-shallow/~/is-primitive/index.js\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":""}