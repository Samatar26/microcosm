{"version":3,"sources":["Microcosm.js","webpack/bootstrap 6801ebff23a8ff99d760","./src/index.js","./src/Heartbeat.js","./src/Microcosm.js","./src/Store.js","./src/assert.js","./src/assign.js","./src/mapBy.js","./src/tag.js","./~/is-equal-shallow/index.js","./~/is-equal-shallow/~/is-primitive/index.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__esModule","tag","_classCallCheck","instance","Constructor","TypeError","Heartbeat","this","_callbacks","prototype","ignore","callback","filter","i","listen","concat","pump","length","_interopRequire","obj","_inherits","subClass","superClass","Object","create","constructor","value","enumerable","writable","configurable","__proto__","Store","assert","assign","isEqual","mapBy","Microcosm","_Heartbeat","_stores","_state","getInitialState","shouldUpdate","prev","next","seed","data","swap","deserialize","has","_this","_len","arguments","stores","Array","_key","some","a","b","get","key","merge","prepare","fn","_send","buffer","send","bind","apply","params","request","Promise","then","body","dispatch","action","answerable","store","changes","addStore","safe","map","s","join","serialize","toJSON","undefined","state","toString","Error","bool","message","error","framesToPop","_extends","target","source","hasOwnProperty","array","reduce","memo","uid","isFunction","decorate","copy","actions","keys","isPrimitive"],"mappings":"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","file":"Microcosm.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports.__esModule = true;\n\t/**\n\t * Microcosm\n\t * An isomorphic flux implimentation. The strength of Microcosm\n\t * is that each application is its own fully encapsulated world\n\t */\n\n\tvar tag = __webpack_require__(7);\n\texports.tag = tag;\n\texports[\"default\"] = __webpack_require__(2);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n\t/**\n\t * Heartbeat\n\t * A singular event emitter. Heartbeat simply pumps blood.\n\t */\n\n\tvar Heartbeat = (function () {\n\t  function Heartbeat() {\n\t    _classCallCheck(this, Heartbeat);\n\n\t    this._callbacks = [];\n\t  }\n\n\t  /**\n\t   * Given a CALLBACK function, remove it from the Set of callbacks.\n\t   * Throws an error if the callback is not included in the Set.\n\t   */\n\n\t  Heartbeat.prototype.ignore = function ignore(callback) {\n\t    this._callbacks = this._callbacks.filter(function (i) {\n\t      return i !== callback;\n\t    });\n\t  };\n\n\t  /**\n\t   * Given a CALLBACK function, add it to the Set of all callbacks.\n\t   */\n\n\t  Heartbeat.prototype.listen = function listen(callback) {\n\t    this._callbacks = this._callbacks.concat(callback);\n\t  };\n\n\t  /**\n\t   * Trigger every callback in the Set\n\t   */\n\n\t  Heartbeat.prototype.pump = function pump() {\n\t    /**\n\t     * Important: do not cache the length of _callbacks\n\t     * in the event a callback causes later subscriptions\n\t     * to disappear\n\t     */\n\t    for (var i = 0; i < this._callbacks.length; i++) {\n\t      this._callbacks[i].call(this);\n\t    }\n\t  };\n\n\t  return Heartbeat;\n\t})();\n\n\tmodule.exports = Heartbeat;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\n\tvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\n\tvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n\t/**\n\t * Microcosm\n\t * An isomorphic flux implimentation. The strength of Microcosm\n\t * is that each application is its own fully encapsulated world\n\t */\n\n\tvar Heartbeat = _interopRequire(__webpack_require__(1));\n\n\tvar Store = _interopRequire(__webpack_require__(3));\n\n\tvar assert = _interopRequire(__webpack_require__(4));\n\n\tvar assign = _interopRequire(__webpack_require__(5));\n\n\tvar isEqual = _interopRequire(__webpack_require__(8));\n\n\tvar mapBy = _interopRequire(__webpack_require__(6));\n\n\tvar Microcosm = (function (_Heartbeat) {\n\t  function Microcosm() {\n\t    _classCallCheck(this, Microcosm);\n\n\t    _Heartbeat.call(this);\n\n\t    this._stores = [];\n\t    this._state = this.getInitialState();\n\t  }\n\n\t  _inherits(Microcosm, _Heartbeat);\n\n\t  Microcosm.prototype.getInitialState = function getInitialState() {\n\t    // Assigns the default state. Most of the time this will not need\n\t    // to be overridden, however if using something like ImmutableJS,\n\t    // you could return a different data structure here.\n\t    return {};\n\t  };\n\n\t  Microcosm.prototype.shouldUpdate = function shouldUpdate(prev, next) {\n\t    // Whenever an action is dispatched, the resulting state\n\t    // modification will be diffed to identify if a change event\n\t    // should fire.\n\t    //\n\t    // The default strategy for determining that state has changed\n\t    // is a simple shallow equals check\n\t    return isEqual(prev, next) == false;\n\t  };\n\n\t  Microcosm.prototype.seed = function seed(data) {\n\t    // Tells the microcosm how it should handle data injected from\n\t    // sources.\n\t    //\n\t    // By default, it will clean the data with `deserialize` and\n\t    // then override the existing data set with the new values\n\t    this.swap(this.deserialize(data));\n\t  };\n\n\t  Microcosm.prototype.has = function has() {\n\t    var _this = this;\n\n\t    for (var _len = arguments.length, stores = Array(_len), _key = 0; _key < _len; _key++) {\n\t      stores[_key] = arguments[_key];\n\t    }\n\n\t    return stores.some(function (a) {\n\t      return _this._stores.some(function (b) {\n\t        return \"\" + a === \"\" + b;\n\t      });\n\t    });\n\t  };\n\n\t  Microcosm.prototype.get = function get(key) {\n\t    // How state should be retrieved. This function is useful to\n\t    // override with the particular method of retrieval for the data\n\t    // structure returned from `getInitialState`\n\t    return this._state[key];\n\t  };\n\n\t  Microcosm.prototype.swap = function swap(next) {\n\t    // Given a next state, only trigger an event if state actually changed\n\t    if (this.shouldUpdate(this._state, next)) {\n\t      this._state = next;\n\t      this.pump();\n\t    }\n\t  };\n\n\t  Microcosm.prototype.merge = function merge(obj) {\n\t    // How state should be re-assigned. This function is useful to\n\t    // override with the particular method of assignment for the data\n\t    // structure returned from `getInitialState`\n\t    this.swap(assign(this._state, obj));\n\t  };\n\n\t  Microcosm.prototype.prepare = function prepare(fn) {\n\t    var _send;\n\n\t    for (var _len = arguments.length, buffer = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      buffer[_key - 1] = arguments[_key];\n\t    }\n\n\t    return (_send = this.send).bind.apply(_send, [this, fn].concat(buffer));\n\t  };\n\n\t  Microcosm.prototype.send = function send(fn) {\n\t    var _this = this;\n\n\t    for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      params[_key - 1] = arguments[_key];\n\t    }\n\n\t    var request = fn.apply(this, params);\n\n\t    // Actions some times return promises. When this happens, wait for\n\t    // them to resolve before moving on\n\t    if (request instanceof Promise) {\n\t      return request.then(function (body) {\n\t        return _this.dispatch(fn, body);\n\t      });\n\t    }\n\n\t    return this.dispatch(fn, request);\n\t  };\n\n\t  Microcosm.prototype.dispatch = function dispatch(action, body) {\n\t    var _this = this;\n\n\t    // First get all stores that can repond to this action\n\t    var answerable = this._stores.filter(function (store) {\n\t      return action in store;\n\t    });\n\n\t    // Next build the change set\n\t    var changes = mapBy(answerable, function (store) {\n\t      return store[action](_this.get(store), body);\n\t    });\n\n\t    // Produce the next state by mapBying changes into the current state\n\t    this.merge(changes);\n\n\t    // Send back the body to the original signaler\n\t    return body;\n\t  };\n\n\t  Microcosm.prototype.addStore = function addStore() {\n\t    for (var _len = arguments.length, stores = Array(_len), _key = 0; _key < _len; _key++) {\n\t      stores[_key] = arguments[_key];\n\t    }\n\n\t    // Make sure that the Store implements important life cycle methods\n\t    var safe = stores.map(function (s) {\n\t      return assign(Store, s);\n\t    });\n\n\t    // Don't reassign stores that are already included\n\t    // fail hard\n\t    assert(!this.has(safe), \"A toString method within \\\"\" + stores.join(\", \") + \"\\\" is not unique\");\n\n\t    // Add the validated stores to the list of known entities\n\t    this._stores = this._stores.concat(safe);\n\n\t    // Once verified, setup initial state.\n\t    // This is done last so that any callbacks that need to reduce\n\t    // over the current state have the latest list of stores\n\t    this.merge(mapBy(safe, function (s) {\n\t      return s.getInitialState();\n\t    }));\n\t  };\n\n\t  Microcosm.prototype.serialize = function serialize() {\n\t    var _this = this;\n\n\t    return mapBy(this._stores, function (store) {\n\t      return store.serialize(_this.get(store));\n\t    });\n\t  };\n\n\t  Microcosm.prototype.deserialize = function deserialize(data) {\n\t    return mapBy(this._stores, function (store) {\n\t      return store.deserialize(data[store]);\n\t    });\n\t  };\n\n\t  Microcosm.prototype.toJSON = function toJSON() {\n\t    return this.serialize();\n\t  };\n\n\t  return Microcosm;\n\t})(Heartbeat);\n\n\tmodule.exports = Microcosm;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tmodule.exports = {\n\n\t  getInitialState: function getInitialState() {\n\t    return undefined;\n\t  },\n\n\t  serialize: function serialize(state) {\n\t    return state;\n\t  },\n\n\t  deserialize: function deserialize() {\n\t    var state = arguments[0] === undefined ? this.getInitialState() : arguments[0];\n\n\t    return state;\n\t  },\n\n\t  toString: function toString() {\n\t    throw new Error(\"Stores must implement a toString() method\");\n\t  }\n\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * assert\n\t * If not true, throw an error\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = assert;\n\n\tfunction assert(bool, message) {\n\t  if (!bool) {\n\t    var error = new Error(message);\n\n\t    // Remove `assert` from the stack\n\t    error.framesToPop = 1;\n\n\t    throw error;\n\t  }\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\t/**\n\t * assign\n\t * Non-destructively assign one object into another\n\t */\n\n\tmodule.exports = assign;\n\n\tfunction assign(a, b) {\n\t  return _extends({}, a, b);\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * MapBy\n\t * Take a list and reduce it into an object\n\t *\n\t * Name comes from:\n\t * http://www.reddit.com/r/Clojure/comments/307rkc/a_mapify_function/\n\t */\n\n\t\"use strict\";\n\n\tmodule.exports = mapBy;\n\n\tfunction mapBy(array, fn) {\n\t  return array.reduce(function (memo, next) {\n\t    memo[next] = fn(next);\n\t    return memo;\n\t  }, {});\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Tag\n\t * Given an object of methods, modify each method to\n\t * return a unique id when stringifyed\n\t */\n\n\t\"use strict\";\n\n\tvar uid = 0;\n\n\tvar isFunction = function (value) {\n\t  return typeof value === \"function\";\n\t};\n\n\tvar decorate = function (fn, key) {\n\t  var copy = fn.bind(null);\n\t  var id = \"_\" + key + \"_\" + uid++;\n\n\t  copy.toString = function () {\n\t    return id;\n\t  };\n\n\t  return copy;\n\t};\n\n\tmodule.exports = function (actions) {\n\t  var keys = Object.keys(actions);\n\n\t  return keys.reduce(function (memo, key) {\n\t    var value = actions[key];\n\n\t    memo[key] = isFunction(value) ? decorate(value, key) : value;\n\n\t    return memo;\n\t  }, {});\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * is-equal-shallow <https://github.com/jonschlinkert/is-equal-shallow>\n\t *\n\t * Copyright (c) 2015, Jon Schlinkert.\n\t * Licensed under the MIT License.\n\t */\n\n\t'use strict';\n\n\tvar isPrimitive = __webpack_require__(9);\n\n\tmodule.exports = function isEqual(a, b) {\n\t  if (!a && !b) { return true; }\n\t  if (!a && b || a && !b) { return false; }\n\n\t  for (var key in b) {\n\t    if (!isPrimitive(b[key]) || !a.hasOwnProperty(key) || (a[key] !== b[key])) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * is-primitive <https://github.com/jonschlinkert/is-primitive>\n\t *\n\t * Copyright (c) 2014 Jon Schlinkert, contributors.\n\t * Licensed under the MIT License\n\t */\n\n\t'use strict';\n\n\t// see http://jsperf.com/testing-value-is-primitive/5\n\tmodule.exports = function isPrimitive(value) {\n\t  switch (typeof value) {\n\t    case \"string\":\n\t    case \"number\":\n\t    case \"boolean\":\n\t    case \"symbol\":\n\t      return true;\n\t    }\n\n\t  return value == null;\n\t};\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** Microcosm.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6801ebff23a8ff99d760\n **/","/**\n * Microcosm\n * An isomorphic flux implimentation. The strength of Microcosm\n * is that each application is its own fully encapsulated world\n */\n\nexport let tag = require('./tag')\nexport default require('./Microcosm')\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/**\n * Heartbeat\n * A singular event emitter. Heartbeat simply pumps blood.\n */\n\nexport default class Heartbeat {\n\n  constructor() {\n    this._callbacks = []\n  }\n\n  /**\n   * Given a CALLBACK function, remove it from the Set of callbacks.\n   * Throws an error if the callback is not included in the Set.\n   */\n  ignore(callback) {\n    this._callbacks = this._callbacks.filter(i => i !== callback)\n  }\n\n  /**\n   * Given a CALLBACK function, add it to the Set of all callbacks.\n   */\n  listen(callback) {\n    this._callbacks = this._callbacks.concat(callback)\n  }\n\n  /**\n   * Trigger every callback in the Set\n   */\n  pump() {\n    /**\n     * Important: do not cache the length of _callbacks\n     * in the event a callback causes later subscriptions\n     * to disappear\n     */\n    for (var i = 0; i < this._callbacks.length; i++) {\n      this._callbacks[i].call(this)\n    }\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Heartbeat.js\n **/","/**\n * Microcosm\n * An isomorphic flux implimentation. The strength of Microcosm\n * is that each application is its own fully encapsulated world\n */\n\nimport Heartbeat from './Heartbeat'\nimport Store     from './Store'\nimport assert    from './assert'\nimport assign    from './assign'\nimport isEqual   from 'is-equal-shallow'\nimport mapBy     from './mapBy'\n\nexport default class Microcosm extends Heartbeat {\n\n  constructor() {\n    super()\n\n    this._stores = []\n    this._state  = this.getInitialState()\n  }\n\n  getInitialState() {\n    // Assigns the default state. Most of the time this will not need\n    // to be overridden, however if using something like ImmutableJS,\n    // you could return a different data structure here.\n    return {}\n  }\n\n  shouldUpdate(prev, next) {\n    // Whenever an action is dispatched, the resulting state\n    // modification will be diffed to identify if a change event\n    // should fire.\n    //\n    // The default strategy for determining that state has changed\n    // is a simple shallow equals check\n    return isEqual(prev, next) == false\n  }\n\n  seed(data) {\n    // Tells the microcosm how it should handle data injected from\n    // sources.\n    //\n    // By default, it will clean the data with `deserialize` and\n    // then override the existing data set with the new values\n    this.swap(this.deserialize(data))\n  }\n\n  has(...stores) {\n    return stores.some(a => this._stores.some(b => `${a}` === `${b}`))\n  }\n\n  get(key) {\n    // How state should be retrieved. This function is useful to\n    // override with the particular method of retrieval for the data\n    // structure returned from `getInitialState`\n    return this._state[key]\n  }\n\n  swap(next) {\n    // Given a next state, only trigger an event if state actually changed\n    if (this.shouldUpdate(this._state, next)) {\n      this._state = next\n      this.pump()\n    }\n  }\n\n  merge(obj) {\n    // How state should be re-assigned. This function is useful to\n    // override with the particular method of assignment for the data\n    // structure returned from `getInitialState`\n    this.swap(assign(this._state, obj))\n  }\n\n  prepare(fn, ...buffer) {\n    return this.send.bind(this, fn, ...buffer)\n  }\n\n  send(fn, ...params) {\n    let request = fn.apply(this, params)\n\n    // Actions some times return promises. When this happens, wait for\n    // them to resolve before moving on\n    if (request instanceof Promise) {\n      return request.then(body => this.dispatch(fn, body))\n    }\n\n    return this.dispatch(fn, request)\n  }\n\n  dispatch(action, body) {\n    // First get all stores that can repond to this action\n    let answerable = this._stores.filter(store => action in store)\n\n    // Next build the change set\n    let changes = mapBy(answerable, store => store[action](this.get(store), body))\n\n    // Produce the next state by mapBying changes into the current state\n    this.merge(changes)\n\n    // Send back the body to the original signaler\n    return body\n  }\n\n  addStore(...stores) {\n    // Make sure that the Store implements important life cycle methods\n    let safe = stores.map(s => assign(Store, s))\n\n    // Don't reassign stores that are already included\n    // fail hard\n    assert(!this.has(safe), `A toString method within \"${stores.join(', ')}\" is not unique`)\n\n    // Add the validated stores to the list of known entities\n    this._stores = this._stores.concat(safe)\n\n    // Once verified, setup initial state.\n    // This is done last so that any callbacks that need to reduce\n    // over the current state have the latest list of stores\n    this.merge(mapBy(safe, s => s.getInitialState()))\n  }\n\n  serialize() {\n    return mapBy(this._stores, store => store.serialize(this.get(store)))\n  }\n\n  deserialize(data) {\n    return mapBy(this._stores, store => store.deserialize(data[store]))\n  }\n\n  toJSON() {\n    return this.serialize()\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Microcosm.js\n **/","export default {\n\n  getInitialState() {\n    return undefined\n  },\n\n  serialize(state) {\n    return state\n  },\n\n  deserialize(state = this.getInitialState()) {\n    return state\n  },\n\n  toString() {\n    throw new Error('Stores must implement a toString() method')\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Store.js\n **/","/**\n * assert\n * If not true, throw an error\n */\n\nexport default function assert (bool, message) {\n  if (!bool) {\n    let error = new Error(message)\n\n    // Remove `assert` from the stack\n    error.framesToPop = 1;\n\n    throw error\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/assert.js\n **/","/**\n * assign\n * Non-destructively assign one object into another\n */\n\nexport default function assign (a, b) {\n  return { ...a, ...b }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/assign.js\n **/","/*\n * MapBy\n * Take a list and reduce it into an object\n *\n * Name comes from:\n * http://www.reddit.com/r/Clojure/comments/307rkc/a_mapify_function/\n */\n\nexport default function mapBy (array, fn) {\n  return array.reduce(function(memo, next) {\n    memo[next] = fn(next)\n    return memo\n  }, {})\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/mapBy.js\n **/","/**\n * Tag\n * Given an object of methods, modify each method to\n * return a unique id when stringifyed\n */\n\nlet uid = 0\n\nlet isFunction = value => typeof value === 'function'\n\nlet decorate = (fn, key) => {\n  let copy = fn.bind(null)\n  let id   = `_${ key }_${ uid++ }`\n\n  copy.toString = () => id\n\n  return copy\n}\n\nexport default actions => {\n  let keys = Object.keys(actions)\n\n  return keys.reduce((memo, key) => {\n    let value = actions[key]\n\n    memo[key] = isFunction(value) ? decorate(value, key) : value\n\n    return memo\n  }, {})\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/tag.js\n **/","/*!\n * is-equal-shallow <https://github.com/jonschlinkert/is-equal-shallow>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar isPrimitive = require('is-primitive');\n\nmodule.exports = function isEqual(a, b) {\n  if (!a && !b) { return true; }\n  if (!a && b || a && !b) { return false; }\n\n  for (var key in b) {\n    if (!isPrimitive(b[key]) || !a.hasOwnProperty(key) || (a[key] !== b[key])) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/is-equal-shallow/index.js\n ** module id = 8\n ** module chunks = 0\n **/","/*!\n * is-primitive <https://github.com/jonschlinkert/is-primitive>\n *\n * Copyright (c) 2014 Jon Schlinkert, contributors.\n * Licensed under the MIT License\n */\n\n'use strict';\n\n// see http://jsperf.com/testing-value-is-primitive/5\nmodule.exports = function isPrimitive(value) {\n  switch (typeof value) {\n    case \"string\":\n    case \"number\":\n    case \"boolean\":\n    case \"symbol\":\n      return true;\n    }\n\n  return value == null;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/is-equal-shallow/~/is-primitive/index.js\n ** module id = 9\n ** module chunks = 0\n **/"],"sourceRoot":""}