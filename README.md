# Microcosm

Flux with central, isolated state.

![CircleCI](https://circleci.com/gh/vigetlabs/microcosm.svg?style=svg)

## Table of Contents

1. [Documentation](docs)
2. [Overview](#overview)
3. [Opinions](#opinions)
4. [What is it trying to solve?](#what-is-it-trying-to-solve)

## Overview

Microcosm is a variant of [Flux](https://facebook.github.io/flux/)
that makes it easier to control and modify state in a pure,
centralized way. It thinks of stores and actions as stateless
collections of pure functions, keeping all data encapsulated in a
specific instance of Microcosm.

This design seeks to achieve a reasonable trade off between the
simplicity of singletons and the privacy of class instances.

### No action constants

Microcosm automatically generates action type constants based upon the
referential identity of the action and the current state of its
lifecycle.

An action can be in several states: `open`, `loading`, `done`,
`failed`, and `cancelled`. Stores can subscribe to each of these
states through the use of a `register` function:

```javascript
function createPlanet (params) {
  return ajax.post('/planets', params)
}

app.addStore('planets', {
  getInitialState() {
    return { records: [], loading: false }
  },

  addPlanet(planets, props) {
    return { ...planets, records: planets.records.concat(props) }
  },

  setLoading(planets) {
    return { ...planets, loading: true }
  },

  register() {
    [createPlanet]      : this.addPlanet,
    [createPlanet.open] : this.setLoading,
  }
})


// Creates a action of type "createPlanet" that dispatches to stores
app.push(createPlanet, params)
```

When an action is pushed, it is placed into a journal of all actions
that have occurred. During the `open` state, the action is in a state
where the request has been opened however it is not complete. When the
request finishes, the action spawned by `createPlanet` will move into
a `done` state. Microcosm will then re-run through the list of actions
documented in the journey to produce a new application state that
accounts for the completion of the request.

This is heavily inspired by event sourced message queues, such as
[Apache Kafka](http://kafka.apache.org/), or the
[LMAX Architecture](http://martinfowler.com/articles/lmax.html),
though there is significant difference in implementation.

Visit [the API documentation for actions](./docs/api/actions.md) to
read more.

### Stores

Stores hold no state; instead they are responsible for writing state
to the repository owned by a Microcosm instance.

This allows stores to be simple collections of pure functions that
transform old data into new data. The `register` hook tells Microcosm
what actions a store should respond to:

```javascript
const Planets = {
  // Tells a Microcosm how a store should respond to actions
  register() {
    return {
      [addPlanet] : this.add
    }
  },
  // Store handlers are pure functions that take an old state and
  // transform it into a new state
  add(planets, props) {
    return planets.concat(props)
  }
}
```

Visit [the API documentation for stores](./docs/api/stores.md) to
read more.

### Launching an app

Once stores have been added to a Microcosm, it is ready to begin
work. For example, an app's state can be sent down to a component tree:

```javascript
const app = new Microcosm()

// All state is contained in `app`, but transformed with `Planets`
app.addStore(Planets, 'planets')

React.render(<SolarSystem app={ app } planets={ app.state.planets } />, document.getElementById(entry'))
```

## Opinions

1. Action CONSTANTS are automatically generated by assigning
   each Action function a unique `toString` signature under the hood.
3. Actions handle all asynchronous operations. Stores are
   synchronous.
3. Stores do not contain data, they _transform_ it.

## What is it trying to solve?

1. State isolation. Requests to render applications server-side should
   be as stateless as possible. Client-side libraries (such as
   [Colonel Kurtz](https://github.com/vigetlabs/colonel-kurtz)) need easy
   containment from other instances on the page.
2. Singletons are simple, but make it easy to accidentally share
   state. Microcosm keeps data in one place, operating on it
   statelessly in other entities.
3. Easy extension of core API and layering of features out of the
   framework's scope.

## Inspiration

- [Worlds](http://www.vpri.org/pdf/rn2008001_worlds.pdf)
- [Om](https://github.com/omcljs/om)
- [Elm Language](https://elm-lang.org)
- [Flummox](https://github.com/acdlite/flummox)
- [But the world is mutable](http://www.lispcast.com/the-world-is-mutable)
- [Event Sourcing Pattern](http://martinfowler.com/eaaDev/EventSourcing.html)
- [Apache Kafka](http://kafka.apache.org/)
- [LMAX Architecture](http://martinfowler.com/articles/lmax.html)

***

<a href="http://code.viget.com">
  <img src="http://code.viget.com/github-banner.png" alt="Code At Viget">
</a>

Visit [code.viget.com](http://code.viget.com) to see more projects from [Viget.](https://viget.com)
